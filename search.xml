<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git免费建站]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Fgit%E5%85%8D%E8%B4%B9%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[记录Hexo+Github免费搭建个人博客Jekyll 到 GitHub Pages 安装hexo 12345npm uninstall -g hexo-clirm /usr/local/bin/hexorm -rf node_modulesnpm installnpm install -g hexo-cli 安装成功大概是这样的 安装失败把C:\Users\admin\AppData\Roaming\npm\node_modules 下hexo-cli文件夹删除]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML-5-Web-存储-sessionStorage和localStorage]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FHTML-5-Web-%E5%AD%98%E5%82%A8-sessionStorage%E5%92%8ClocalStorage%2F</url>
    <content type="text"><![CDATA[HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。 Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生（来自@otakustay 的纠正） html5 web storage的浏览器支持情况浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 要判断浏览器是否支持localStorage可以使用下面的代码：123456789if(window.localStorage)&#123; alert(&quot;浏览支持localStorage&quot;)&#125;else&#123; alert(&quot;浏览暂不支持localStorage&quot;)&#125;//或者if(typeof window.localStorage == &apos;undefined&apos;)&#123; alert(&quot;浏览暂不支持localStorage&quot;)&#125; localStorage和sessionStorage操作localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 setItem存储value12sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);localStorage.setItem(&quot;site&quot;, &quot;js8.in&quot;); getItem获取value 12var value = sessionStorage.getItem(&quot;key&quot;);var site = localStorage.getItem(&quot;site&quot;); removeItem删除key12sessionStorage.removeItem(&quot;key&quot;);localStorage.removeItem(&quot;site&quot;); clear清除所有的key/value12sessionStorage.clear();localStorage.clear(); 其他操作方法：点操作和[] web Storage不但可以用自身的setItem,getItem等方便存取，也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储，像如下的代码： 123456var storage = window.localStorage;for (var i=0, len = storage.length; i &lt; len; i++)&#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + &quot;=&quot; + value);&#125; storage事件 storage还提供了storage事件，当键值改变或者clear的时候，就可以触发storage事件，如下面的代码就添加了一个storage事件改变的监听： 123456789if(window.addEventListener)&#123; window.addEventListener(&quot;storage&quot;,handle_storage,false);&#125;else if(window.attachEvent)&#123; window.attachEvent(&quot;onstorage&quot;,handle_storage);&#125;function handle_storage(e)&#123; if(!e)&#123;e=window.event;&#125;&#125;]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML-5-视频,音频]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FHTML-5-%E8%A7%86%E9%A2%91%2C%E9%9F%B3%E9%A2%91%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_video.asphttp://www.w3school.com.cn/html5/html_5_video_dom.asphttp://www.w3school.com.cn/html5/html_5_audio.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5-Input-类型]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FHTML5-Input-%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_form_input_types.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5-服务器发送事件（server-sent-event）允许网页获得来自服务器的更新。]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FHTML5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%EF%BC%88server-sent-event%EF%BC%89%E5%85%81%E8%AE%B8%E7%BD%91%E9%A1%B5%E8%8E%B7%E5%BE%97%E6%9D%A5%E8%87%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9B%B4%E6%96%B0%E3%80%82%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_serversentevents.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5-的新的表单属性]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2FHTML5-%E7%9A%84%E6%96%B0%E7%9A%84%E8%A1%A8%E5%8D%95%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_form_attributes.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2Fsvg%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_svg.asphttp://www.w3school.com.cn/svg/index.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web-worker-是运行在后台的-JavaScript，不会影响页面的性能。]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2Fweb-worker-%E6%98%AF%E8%BF%90%E8%A1%8C%E5%9C%A8%E5%90%8E%E5%8F%B0%E7%9A%84-JavaScript%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%80%A7%E8%83%BD%E3%80%82%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_webworkers.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用-HTML5，通过创建-cache-manifest-文件，可以轻松地创建-web-应用的离线版本。]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E4%BD%BF%E7%94%A8-HTML5%EF%BC%8C%E9%80%9A%E8%BF%87%E5%88%9B%E5%BB%BA-cache-manifest-%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BD%BB%E6%9D%BE%E5%9C%B0%E5%88%9B%E5%BB%BA-web-%E5%BA%94%E7%94%A8%E7%9A%84%E7%A6%BB%E7%BA%BF%E7%89%88%E6%9C%AC%E3%80%82%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_app_cache.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[地理定位]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_geolocation.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[画布]]></title>
    <url>%2F2017%2F11%2F15%2FHTML-5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E7%94%BB%E5%B8%83%2F</url>
    <content type="text"><![CDATA[http://www.w3school.com.cn/html5/html_5_canvas.asp]]></content>
      <categories>
        <category>HTML-5学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HashMap解读]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FHashMap%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[目的：java中为实现能够从一个数量庞大的容器中取出某一个容器（快速查找），做了这个容器Map，而HashMap是Map容器的一种实现，基于数学中的散列。 数学基础:有人总结了，可以看看 Hash算法总结 1. 概述 从本文你可以学习到： 什么时候会使用HashMap？他有什么特点？你知道HashMap的工作原理吗？你知道get和put的原理吗？equals()和hashCode()的都有什么作用？你知道hash的实现吗？为什么要这样实现？如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 当我们执行下面的操作时：123456789101112HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(&quot;语文&quot;, 1);map.put(&quot;数学&quot;, 2);map.put(&quot;英语&quot;, 3);map.put(&quot;历史&quot;, 4);map.put(&quot;政治&quot;, 5);map.put(&quot;地理&quot;, 6);map.put(&quot;生物&quot;, 7);map.put(&quot;化学&quot;, 8);for(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());&#125; 运行结果是:政治: 5生物: 7历史: 4数学: 2化学: 8语文: 1英语: 3地理: 6 发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：在官方文档中是这样描述HashMap的： Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. 几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。 2. 两个重要的参数在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor) Initial capacity The capacity is the number of buckets in the hash table, The initial capacity is simply the capacity at the time the hash table is created.Load factor The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. 简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。 3. put函数的实现put函数大致的思路为： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。具体代码的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 节点存在 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 写入 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 超过load factor*current capacity，resize if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 4. get函数的实现在理解了put之后，get就很简单了。大致思路如下： bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。 具体代码的实现如下： 123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 直接命中 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 未命中 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 5. hash函数的实现在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：在对hashCode()计算hash时具体实现是这样的：可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的： Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： 设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。 因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。 如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题： Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.之前已经提过，在获取HashMap的元素时，基本分两步： 首先根据hashCode()做hash，然后确定bucket的index； 如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。 6. RESIZE的实现当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的： Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table. 大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 下面是代码的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 7. 总结 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。关于Java集合的小抄中是这样描述的： 以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。iterator()时顺着哈希桶数组来遍历，看起来是个乱序。在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。 参考资料：HashMap的工作原理Java 8：HashMap的性能提升JEP 180: Handle Frequent HashMap Collisions with Balanced TreesConurrentHashMap和Hashtable的区别HashMap和Hashtable的区别]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-ArrayDeque工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-ArrayDeque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/11/Java-ArrayDeque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-ArrayList工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-EnumMap工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-EnumMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/24/Java-EnumMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-HashSet工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/08/Java-HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-LinkedHashMap工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述 在理解了#7 介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序： 运行结果是：我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识： 三个重点实现的函数 在HashMap中提到了下面的定义：LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。afterNodeAccess函数 http://yikun.github.io/2015/04/02/Java-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-LinkedHashSet工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-LinkedHashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/09/Java-LinkedHashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-LinkedList工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-LinkedList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/05/Java-LinkedList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-PriorityQueue工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-PriorityQueue%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/07/Java-PriorityQueue%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-TreeMap工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-TreeSet工作原理及实现]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava-TreeSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[http://yikun.github.io/2015/04/10/Java-TreeSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架]]></title>
    <url>%2F2017%2F11%2F15%2FJava8%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%A7%A3%E8%AF%BB%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Java集合框架，是以数据结构为基础，存储、操作大量数据的容器官方解释：Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。 Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了：接口，实现，算法 Interfaces:这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构； Implementations:这些是接口的具体实现。本质上，是一些可复用的数据结构； Algorithms:这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。 接口12345678910public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125;public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125;public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123;&#125;public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123;&#125;public interface Map&lt;K,V&gt; &#123;&#125;public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123;&#125;public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123;&#125; Collection： 集合层次中的根。一个集合表示一组对象。有些有序，有些无序。有些重复，有些重复。Collection没有直接的实现，而只有它的子接口的对应的实现。 Set：不能包含重复的元素，比如扑克手牌、学生选课计划、计算机的进程。 List：有序的集合，也可以包含重复的元素。用于对每个元素精确的控制，比如插入、用index来索引。 Queue：用于多元素有优先级的处理，可以用做FIFO Deque：用于多元素有优先级的处理，double ended queue，可以用作FIFO，LIFO Map：用于keys到values的映射，不能包含重复元素另外还提供了2个带排序的Set和Map。 SortedSet：元素升序 SortedMap：key升序在1.6版本开始，还有两种新的接口NavigableSet、NavigableMap。]]></content>
      <categories>
        <category>Java8集合框架解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DispatcherServlet]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2FDispatcherServlet%2F</url>
    <content type="text"><![CDATA[DispatcherServlet是一个实际的Servlet（它从HttpServlet基类继承），因此web.xml在您的Web应用程序中声明。您需要DispatcherServlet通过在同一web.xml文件中使用URL映射来映射要处理的请求。这是标准的Java EE Servlet配置; 以下示例显示了这样的DispatcherServlet声明和映射：xml配置12345678910111213&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;example&lt;/servlet-name&gt; &lt;url-pattern&gt;/example/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 所有从头开始的请求/example都将被DispatcherServlet命名的实例处理 example。在Servlet 3.0+环境中，您还可以以编程方式配置Servlet容器。以下是与上述web.xml例子相当的代码：12345678public class MyWebApplicationInitializer implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext container) &#123; ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping(&quot;/example/*&quot;); &#125;&#125; WebApplicationInitializer是由Spring MVC提供的interface，可确保您的基于代码的配置被检测并自动用于初始化任何Servlet 3容器。这个接口的抽象基类实现AbstractDispatcherServletInitializer使得DispatcherServlet通过简单地指定其servlet映射更容易注册。有关详细信息，请参阅基于代码的Servlet容器初始化。]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-3官方文档整理]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2FMyBatis-3%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[安装要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：123456&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;`]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MyBatis3-xml映射文件配置]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2FMyBatis3-xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。与具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。 MyBatis3官方文档 http://www.mybatis.org/mybatis-3/zh/index.html]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC常用注解]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2FSpring-MVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[启用包扫描逐渐功能：&lt;context:component-scan base-package=&quot;org.xxx.xxx&quot;例如：123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;org.springframework.samples.petclinic.web&quot;/&gt; &lt;!-- ... --&gt;&lt;/beans&gt; @Controller指示一个控制器。 @RequestMapping请求动作映射,@RequestMapping注释来将URL映射/appointments到整个类或特定的处理程序方法 属性： value:String[]类型，非必需，用于将请求的实际地址映射到方法上 name:String 类型，非必需，给映射地址一个别名 method:RequestMethod[],非必需，指定请求类型，GET,POST,HEAD,OPTIONS,PUT,PATCH,DELETE,TRACE consumes:String[]类型，非必需，指定请求的提交内容类型（Content-Type）如：application/json,text/html等 produces:String类型，非必需，指定返回的内容类型，必须是request请求头重所包含的类型。 params:String[]类型，非必需，指定request中必须包含某些值时，才用这个方法处理。 headers:String[]类型，非必需，指定request中有指定的header时，才用这个方法处理。 Path:String[]类型，非必需，在Servlet环境中，只用uri映射 请求方法中可以出现的参数类型：org.springframework.web.context.request.WebRequestorg.springframework.web.context.request.NativeWebRequestjava.util.Locale 当前请求的语言环境java.util.TimeZone 时区java.io.InputStream或java.io.Readerjava.io.OutputStream或java.io.Writerorg.springframework.http.HttpMethodjava.security.PrincipalHttpEntity &lt;?&gt;参数用于访问Servlet的HTTP请求的标题和内容java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap 视图隐含模型org.springframework.web.servlet.mvc.support.RedirectAttributes 重定向命令或表单对象基本数据类型，如int,String,double…复杂数据类型，如自定义的POJO对象HandlerAdapterorg.springframework.validation.Errors / org.springframework.validation.BindingResult 验证结果org.springframework.web.bind.support.SessionStatus 会话状态org.springframework.web.util.UriComponentsBuilder@PathVariable 注解参数访问URI模板变量。@MatrixVariable 注释参数用于访问位于URI路径段键值对对，矩阵变量。@RequestParam 注解参数访问特定的Servlet请求参数，请求参数绑定。@RequestHeader 注解参数访问特定的se​​rvlet请求HTTP标头，映射请求头。@RequestBody 注解参数访问HTTP请求主体，注解映射请求体@RequestPart 注解参数访问“的multipart / form-data的”请求部分的内容。处理客户端上传文件，多部分文件上传的支持@SessionAttribute 注解参数会话属性@RequestAttribute 注解参数访问请求属性可简记如下：（1 ）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。 （2 ）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。 （3 ）InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。 （4 ）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。 （5 ）使用@ModelAttribute 标记的参数。 （6 ）java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。 （7 ）实体类。 可以用来接收上传的参数。 （8 ）Spring 封装的MultipartFile 。 用来接收上传文件的。 （9 ）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。 请求处理方法可以返回的类型： （1 ）一个包含模型和视图的ModelAndView 对象。 （2 ）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。 （3 ）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。 （4 ）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。 （5 ）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。 （6 ）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。 （7 ）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。 @RequestParam用于将指定的请求参数赋值给方法中的形参。 属性： name:String类型，非必需，指定请求头绑定的名称。 value:String类型， 非必需，namme属性的别名。 required:boolean类型，非必需，指定参数是否必须绑定。 defaultValue:String类型，非必需，参数默认值。 @PathVariable 属性value:String类型，非必需，如果省略则默认绑定同名参数，表示取值uri中的变量值。 @RequestHeader将请求头数据映射到处理方法的参数上。 属性： name:String类型，非必需，请求头绑定的名称。 value:String类型，非必需，name的别名。 required:boolean类型，非必需，指定参数是否必须绑定。 defaultValue:String类型，非必需，参数默认值。 @CookieValue 映射请求头的Cookie信息到处理方法的参数上。 属性： name:String类型，非必需，请求头绑定的名称。 value:String类型，非必需，name的别名。 required:boolean类型，非必需，指定参数是否必须绑定。 defaultValue:String类型，非必需，参数默认值。 @SessionAttributes允许我们有选择的指定Model中的哪些属性需要转存到HttpSession对象中。 属性： names:String[]类型，非必需，Model中属性的名称，即存在HttpSession中的名称。 value:String[]类型，非必需，names属性的别名。 types:Class&lt;?&gt;[],非必需，指定参数是否必须绑定。只能声明在类上，不能声明到方法上。]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mybatis思维导图整理]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2Fmybatis%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 整理自博客：mybatis思维导图，让mybatis不再难懂https://my.oschina.net/u/3080373/blog/880501https://my.oschina.net/u/3080373/blog/884176]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sring-AOP编程Spring-Aspect-Oriented-Programming]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2FSring-AOP%E7%BC%96%E7%A8%8BSpring-Aspect-Oriented-Programming%2F</url>
    <content type="text"><![CDATA[https://my.oschina.net/HeliosFly/blog/395417]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[spring-mvc简介与运行原理]]></title>
    <url>%2F2017%2F11%2F15%2FJava%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%2Fspring-mvc%E7%AE%80%E4%BB%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。(1) Http请求：客户端请求提交到DispatcherServlet。(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。(3) 调用处理器：DispatcherServlet将请求提交到Controller。(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。(8) Http响应：视图负责将结果显示到客户端。 主要注解 ContextLoaderListener在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。 当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param &gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet​。（同类多个节点以出现顺序依次加载） 而spring mvc启动过程大致分为两个过程：ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。DispatcherServlet初始化。 其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。ContextLoaderListener在web.xml中的配置 contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListenerServletContextListener 接口有两个方法:contextInitialized,contextDestroyedDispatcherServletSpring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。流程图在web.xml中的配置 dispatcher org.springframework.web.servlet.DispatcherServlet 1 dispatcher /其中load-on-startup：表示启动容器时初始化该Servlet；url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“.html”表示拦截所有以html为扩展名的请求。在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。[图片上传中。。。（7）]其中，常用的ViewResolver的配置。以jsp作为视图为例 ### 配置上传文件限制MultipartResolver &lt;!– 上传文件大小限制为31M，3110241024 –&gt; ### applicationContext.xml中的标签### 文件上传前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。### 表单 ### 控制器@RequestMapping(path = “/form”, method = RequestMethod.POST) public String handleFormUpload(@RequestParam(“name”) String name, @RequestParam(“file”) MultipartFile file) { if (!file.isEmpty()) { byte[] bytes = file.getBytes(); // store the bytes somewhere return “redirect:uploadSuccess”; } return “redirect:uploadFailure”;}### 异常处理先来说下常见的异常处理有几种方式，如下图：Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。 HandlerExceptionResolver 提供resolveException接口public interface HandlerExceptionResolver { ModelAndView resolveException( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex); } 在BaseController中使用 @ExceptionHandler注解处理异常@ExceptionHandler(Exception.class) public Object exceptionHandler(Exception ex, HttpServletResponse response, HttpServletRequest request) throws IOException { String url = “”; String msg = ex.getMessage(); Object resultModel = null; try { if (ex.getClass() == HttpRequestMethodNotSupportedException.class) { url = “admin/common/500”; System.out.println(“——–毛有找到对应方法———“); } else if (ex.getClass() == ParameterException.class) {//自定义的异常 } else if (ex.getClass() == UnauthorizedException.class) { url = “admin/common/unauth”; System.out.println(“——–毛有权限———“); } String header = req.getHeader(“X-Requested-With”); boolean isAjax = “XMLHttpRequest”.equalsIgnoreCase(header); String method = req.getMethod(); boolean isPost = “POST”.equalsIgnoreCase(method); if (isAjax || isPost) { return Message.error(msg); } else { ModelAndView view = new ModelAndView(url); view.addObject(“error”, msg); view.addObject(“class”, ex.getClass()); view.addObject(“method”, request.getRequestURI()); return view; } } catch (Exception exception) { logger.error(exception.getMessage(), exception); return resultModel; } finally { logger.error(msg, ex); ex.printStackTrace(); } }### 在web.xml中处理异常* 403 /403.html 404 /404.html 500 /500.html java.lang.Exception /500.jsp java.lang.Throwable /500.jsp 来一个问题：HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？ 解答：如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： return a corresponding ModelAndView to forward to, or null for default processing.Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。(1) Http请求：客户端请求提交到DispatcherServlet。(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。(3) 调用处理器：DispatcherServlet将请求提交到Controller。(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。(8) Http响应：视图负责将结果显示到客户端。 主要注解 ContextLoaderListener 在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。 当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param &gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet​。（同类多个节点以出现顺序依次加载） 而spring mvc启动过程大致分为两个过程：ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。DispatcherServlet初始化。 其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。ContextLoaderListener在web.xml中的配置 contextConfigLocation /WEB-INF/applicationContext.xml org.springframework.web.context.ContextLoaderListenerServletContextListener 接口有两个方法:contextInitialized,contextDestroyedDispatcherServletSpring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。流程图在web.xml中的配置 dispatcher org.springframework.web.servlet.DispatcherServlet 1 dispatcher /其中load-on-startup：表示启动容器时初始化该Servlet；url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“.html”表示拦截所有以html为扩展名的请求。在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）[图片上传中。。。（6）]spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。[图片上传中。。。（7）]其中，常用的ViewResolver的配置。以jsp作为视图为例 配置上传文件限制MultipartResolver &lt;!– 上传文件大小限制为31M，3110241024 –&gt; applicationContext.xml中的标签文件上传前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。 表单 控制器@RequestMapping(path = “/form”, method = RequestMethod.POST) public String handleFormUpload(@RequestParam(“name”) String name, @RequestParam(“file”) MultipartFile file) { if (!file.isEmpty()) { byte[] bytes = file.getBytes(); // store the bytes somewhere return “redirect:uploadSuccess”; } return “redirect:uploadFailure”;}异常处理先来说下常见的异常处理有几种方式，如下图：Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。 HandlerExceptionResolver 提供resolveException接口public interface HandlerExceptionResolver { ModelAndView resolveException( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex); } 在BaseController中使用 @ExceptionHandler注解处理异常@ExceptionHandler(Exception.class) public Object exceptionHandler(Exception ex, HttpServletResponse response, HttpServletRequest request) throws IOException { String url = “”; String msg = ex.getMessage(); Object resultModel = null; try { if (ex.getClass() == HttpRequestMethodNotSupportedException.class) { url = “admin/common/500”; System.out.println(“——–毛有找到对应方法———“); } else if (ex.getClass() == ParameterException.class) {//自定义的异常 } else if (ex.getClass() == UnauthorizedException.class) { url = “admin/common/unauth”; System.out.println(“——–毛有权限———“); } String header = req.getHeader(“X-Requested-With”); boolean isAjax = “XMLHttpRequest”.equalsIgnoreCase(header); String method = req.getMethod(); boolean isPost = “POST”.equalsIgnoreCase(method); if (isAjax || isPost) { return Message.error(msg); } else { ModelAndView view = new ModelAndView(url); view.addObject(“error”, msg); view.addObject(“class”, ex.getClass()); view.addObject(“method”, request.getRequestURI()); return view; } } catch (Exception exception) { logger.error(exception.getMessage(), exception); return resultModel; } finally { logger.error(msg, ex); ex.printStackTrace(); } } 在web.xml中处理异常* 403 /403.html 404 /404.html 500 /500.html java.lang.Exception /500.jsp java.lang.Throwable /500.jsp 来一个问题：HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？ 解答：如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。 当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。 API文档中对返回值的解释： return a corresponding ModelAndView to forward to, or null for default processing.]]></content>
      <categories>
        <category>Java主流框架分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装方法和创建数据库]]></title>
    <url>%2F2017%2F11%2F15%2FMongoDb%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[http://wiki.jikexueyuan.com/project/mongodb/mongodb-environment.html]]></content>
      <categories>
        <category>MongoDb学习记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Intellij-IDEA-上使用jfinal]]></title>
    <url>%2F2017%2F11%2F15%2FjFinal%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2FIntellij-IDEA-%E4%B8%8A%E4%BD%BF%E7%94%A8jfinal%2F</url>
    <content type="text"><![CDATA[我就呵呵了 https://my.oschina.net/chixn/blog/471755]]></content>
      <categories>
        <category>jFinal使用记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从今天开始，要入jfinal的坑了，试试这破框架好不好用。]]></title>
    <url>%2F2017%2F11%2F15%2FjFinal%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F%E4%BB%8E%E4%BB%8A%E5%A4%A9%E5%BC%80%E5%A7%8B%EF%BC%8C%E8%A6%81%E5%85%A5jfinal%E7%9A%84%E5%9D%91%E4%BA%86%EF%BC%8C%E8%AF%95%E8%AF%95%E8%BF%99%E7%A0%B4%E6%A1%86%E6%9E%B6%E5%A5%BD%E4%B8%8D%E5%A5%BD%E7%94%A8%E3%80%82%2F</url>
    <content type="text"><![CDATA[公司要用jfinal，所以我要入坑了。听说时去年很火的java框架，不知好不好，试试水吧。 看官网就想吐槽看个文档吧，还要注册。。。现在是2017年吗？？好吧，注册完了，接着就。。。 呵呵，捐助可以，但是你连个在线的文档都么有，下载pdf看多麻烦。现在是2017年了？？？ 呵呵 算了，大项目spring，小项目，php吧，小项目你用什么java。浪费时间感情。 太旧了，跟不上时代步伐。 等我用下框架再评论。]]></content>
      <categories>
        <category>jFinal使用记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[-Linux下Tomcat的启动、关闭、杀死进程]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F-Linux%E4%B8%8BTomcat%E7%9A%84%E5%90%AF%E5%8A%A8%E3%80%81%E5%85%B3%E9%97%AD%E3%80%81%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[打开终端cd /java/tomcat #执行bin/startup.sh #启动tomcatbin/shutdown.sh #停止tomcattail -f logs/catalina.out #看tomcat的控制台输出； #看是否已经有tomcat在运行了ps -ef |grep tomcat #如果有，用kill;kill -9 pid #pid 为相应的进程号 例如 ps -ef |grep tomcat 输出如下sun 5144 1 0 10:21 pts/1 00:00:06 /java/jdk/bin/java -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/java/tomcat/common/endorsed -classpath :/java/tomcat/bin/bootstrap.jar:/java/tomcat/bin/commons-logging-api.jar -Dcatalina.base=/java/tomcat -Dcatalina.home=/java/tomcat -Djava.io.tmpdir=/java/tomcat/temp org.apache.catalina.startup.Bootstrap start 则 5144 就为进程号 pid = 5144kill -9 5144 就可以彻底杀死tomcat #直接查看指定端口的进程pidnetstat -anp|grep 9217 #结果为 tcp 0 0 :::9217 :::* LISTEN 26127/java #则26127为9217这个端口的tomcat进程的pid,然后就可以kill这个进程kill -9 26127 #然后再启动tomcat即可]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[90后的我们，独自漂泊在上海]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F90%E5%90%8E%E7%9A%84%E6%88%91%E4%BB%AC%EF%BC%8C%E7%8B%AC%E8%87%AA%E6%BC%82%E6%B3%8A%E5%9C%A8%E4%B8%8A%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[大学刚毕业的我们，大部分都是农村的我们，老家回不去，这边的房子又买不起的我们，独自一人在上海漂着的我们，没有女朋友，没有车子，没有房子的我们，工作一不小心就被骂的我们，年轻而又执着的我们……公司在上海，住在苏州昆山，每天坐地铁两个小时跨省上班。住在离公司远的地方，房租便宜。但是每天要挤两个小时的地铁，早高峰就是家常便饭。现在才知道，原来还可以做跨省上班。如下的地铁站，熙熙攘攘。。。 其实苏州很美，很漂亮，但我却不喜欢这。这的园林都是假山，没有我家乡山峰的巍峨；这的水都很温柔，没有我家乡的河流波涛汹涌；这里的空气没天都是优，可我却想念北方的雾霾了…… 传说中的上有天堂下有苏杭，在我工作的这里，其实是：梅雨季天天下雨，过了梅雨季的现在每天都是40度的高温，偶尔还有台风，走在路上天空突然就下起了雨是常事。就如网友逗称的一样，出门5分钟，流汗两小时，我开始怀念家乡门口的树荫凉了…… 在看过了江南第一水乡后，我的江南梦就破灭了。梦幻般的水乡，却不在我的心上，我想念我的家乡。这里确实很美，但我却感觉没有根基，空荡荡…… 累了一周，周末的时候出来走走，人来人往的城市却唯独只有自己闲逛，景色再好也不能让你开心。没有熟人，没有朋友，女朋友？呵呵，想什么呢，事业未定我怎么能拉她来受苦？我不舍得，还是单身吧，马上七夕了，远方的那个她，你还好吗…… 水乡看多了其实也就这样，没我家乡的河沟子好。怀念在老家河边能抓鱼的时光了……有时候会很想家，想念远方逐渐老去的爸妈。我妈身体不好，我爸不爱做饭，想着我不在家，他们又吃饭又随便凑合过了，我怎么能不赶紧努力工作，只有好好赚钱早点接他们出来。可是，现在的我们离家那么远又怎么尽孝呢？？ 公司其他的的工资都10k到几十k，我只有几k，梦想着自己月入几万，盘算着实习期什么时候结束，以后要走技术还是走管理，盘算着什么时候能在这买个房子…… 但项目经理会说，你这段代码还有bug，今天加个班吧。于是今晚又要通宵了。我觉得我不是在工作，我是被电脑给上了！每天写代码，改 bug，写文档。超过16小时对着电脑。虽然我很喜欢敲击键盘的感觉，但也知道自己20几岁的年龄已经很久没出去打球，跑步了。坐的腰疼，可是项目还是写不完。今天又走到最后，下班时公司已经没有人了。上海，苏杭，这些祖国的心脏，这些梦一样的地方，90后的我们孤身在这里拼搏，奋斗，为了青春，为了梦想。真的是外边的世界很精彩，外边的世界很彷徨。在刚毕业的日子里，在这个人生中最心烦的一段时光，保持自己的本心，在外边闯一闯。从此踏入江湖，行走四方了。虽然现在生活苦了一点，但未来是光明的，脚踏实地的去拼一场，未来就等着我们！实在混不下去了，咱就回家乡。他们说，梦想还有要有的，万一实现了呢？ 本文我首发在今日头条作者：头条号 / 两毛五哥哥链接：http://toutiao.com/i6315583409959731714/来源：头条号（今日头条旗下创作平台）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AngularJS上传下载文件及$http总结]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FAngularJS%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%8A%24http%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AngularJS上传下载文件及$http总结https://my.oschina.net/u/3298482/blog/903847]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BootStrap可视化布局系统，自动生成代码]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FBootStrap%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B8%83%E5%B1%80%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[http://www.bootcss.com/p/layoutit/]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ditto，免费Windows剪贴板增强小工具，方便地复制粘贴多条记录]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FDitto%EF%BC%8C%E5%85%8D%E8%B4%B9Windows%E5%89%AA%E8%B4%B4%E6%9D%BF%E5%A2%9E%E5%BC%BA%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%96%B9%E4%BE%BF%E5%9C%B0%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Ditto 是 Windows 下一款免费开源的剪贴板增强软件，支持64位操作系统，支持中文，并且提供免安装的便携版。使用它，你只需像往常一些复制东西，然后按下Ctrl+`（数字1前面那个按键），就可以唤出它的界面了，里面记录了所有的复制内容，你可以选择性进行粘贴，非常的方便……Ditto 可以帮助你复制、粘贴多条记录，非常方便！ [图片上传中。。。（1）]既然很多人说它功能强大，那我们就来看看它的强大之处吧。首先，Ditto 有剪贴板搜索功能，当你复制了很多很多东西之后，一条一条地找非常麻烦，而用了 Ditto，搜索一下，技能马上找到特定的记录了，非常方便。第二个亮点是“合并粘贴”。有时在收集资料的时候，可能从多个地方复制多次然后再粘贴到同一个地方去，如果用 ClipX 的话，就要粘贴很多次了。而 Ditto 则可以使用 CTRL 或 Shitft 选择多条记录，然后一次性粘贴出来。[图片上传中。。。（3）]神奇地通过网络同步剪贴板内容：另外，相信大家都听过这样一则笑话：“是这样的张总，你在家里的电脑上按了CTRL+C，然后在公司的电脑上再按CTRL+V是肯定不行的。即使同一篇文章也不行。不不不，多贵的电脑都不行。”其实这个这个笑话还有续集，张总最后说：“王秘书，你明天不用来了，我用的是Ditto……”哈，想必大家都明白了吧 Ditto 的亮点是可以实现剪贴板网络同步功能的，只要两台电脑都装了 Ditto，配置好之后就可以方便地同步剪贴板了。[图片上传中。。。（4）]Ditto 本身实现的网络剪贴板同步是基于两台计算机直连的，两台电脑需处于同一局域网内才能比较方便地使用。不过，像张总一样两台基于互联网的电脑要怎样使用呢？对于这点，有2个比较简单的解决方法：1、使用一些虚拟局域网的软件，譬如 LogMeIn Hamachi，让两台互联网电脑处于同一个虚拟的局域网里面，然后，你懂的……2、你也可以考虑将 Ditto 的数据库文件放到 DropBox、金山快盘或者其他一些同步软件的目录中，间接地实现同步剪贴板的功能。3、或者还有更好的方法，如果你想到了，欢迎分享出来！写在后面：Ditto 还有其他一些功能，包括更换皮肤、统计粘贴数目等等，可自定义的地方也非常多，快捷键、样式、字体等等都已随心改造，值得你去摸索折腾。目前，Ditto 应该是剪贴板增强工具中的佼佼者了，加上开源免费，我们有什么理由不给它上一个“精品”的称号呢！相信使用了它之后，你工作效率又会大大提高，你会爱上它的！哦不，应该说，很可能没了它，你就不再想用那台电脑工作了～]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git，GitHub，码云，Git-Tortoise，完整配置流程]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FGit%EF%BC%8CGitHub%EF%BC%8C%E7%A0%81%E4%BA%91%EF%BC%8CGit-Tortoise%EF%BC%8C%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文适用于github，码云，git协同工具工作的小伙伴，你可以选择git自带命令行协同工作，如果你嫌命令行麻烦，可以安装一个封装了命令行的图形用户界面的软件，git-tortoise进行协同工作。 本文需要频繁使用cmd，如果使用系统的cmd会稍微有点不便所以这里先推荐一款Windows平台上面个人觉得比较好用的一款cmd工具ConEmu ConEmu下载地址：http://www.fosshub.com/ConEmu.html 1. 安装Git，TortoiseGit，准备好Android SDK本文使用版本如下，在Win10上配置，已提供文件的下载地址，如需最新版本可进入官网地址下载。具体的安装步骤本文不做介绍，按照自己的使用习惯自己配置即可。 Git: git-1.8.3-windows-1374045102000.exe 下载地址：https://pan.baidu.com/s/1miBQj8G 官网下载地址1：https://git-scm.com/downloads 官网下载地址2：https://git-for-windows.github.io/ TortoiseGit: TortoiseGit-1.8.16.0-64bit.msi 下载地址：https://pan.baidu.com/s/1kUKzzQv 官网下载地址：https://tortoisegit.org/download/ 2. 配置环境变量，方便从命名行直接访问相关命令 Git根目录 –&gt; 变量名：Git_Home 变量值： C:\Program Files (x86)\GitTortoiseGit根目录 –&gt; 变量名：TortoiseGit_Home 变量值：C:\Program Files\TortoiseGit 备注：如果之前在其他设备上配置过Git和TortoiseGit，这里可以直接拷贝之前的.ssh目录过来使用，就不用做下面的3-9步骤了。如果是第一次配置，或者想重新配置新的账号信息，那么按照下面的步骤依次进行即可。 3. 使用Git 命令行生成公钥和私钥1、进入到系统cmd（使用快捷键Win+R然后输入cmd即可进入）界面（备注：左Shift + 鼠标右键弹出菜单里面，有直接进入命令行的菜单，但是这里千万不要用这个方，因为这里进入的命令行和系统cmd进入的权限不一样，生成的秘钥是不一样的，踩过这个坑），我这里默认路径是C:\Users\Administrator，这个路径没有要求，任何目录都可以，生成钥的时候需要输入密码，这里默认写123456，后面clone代码的时候需要用到。 2、执行命令：ssh-keygen –t rsa –C xxxx@xxx.com 3、输入保存的文件名：id_rsa 4、输入密码：123456 即可成功创建公钥和私钥，这里会保存到C:\Users\Administrator 目录下123456789$ ssh-keygen -t rsa -C username@qq.comGenerating public/private rsa key pair.Enter file in which to save the key (//.ssh/id_rsa): id_rsaEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in id_rsa.Your public key has been saved in id_rsa.pub.The key fingerprint is:08:0f:a3:dd:5f:33:7a:aa:67:ff:e2:c4:1a:5e:21:ac username@qq.com 4. 在当前用户目录创建.ssh目录，并把id_rsa文件放入其中当前用户目录一般是在C盘用户目录下面的Administrator目录或者其他的用户目录（如果为Windows系统创建过其他用户）。 这里我的是C:\Users\Administrator 目录，进入C:\Users\Administrator目录，如果没有 .ssh目录，在当前目录下进入cmd执行命令 mkdir .ssh 即可创建。备注：有些Git版本id_rsa可能不是放到用户目录的.ssh目录，而是放到Git的安装目录下的.ssh。自己在配置过程中如果发现配置不生效，尝试把.ssh目录放到另外一个目录下。 5. 把公钥上传到服务器用文本文件打开id_rsa.pub，复制里面的全部文本，登录代码仓库服务器，添加新的ssh-key，粘贴复制的内容到key里面，Title会自动生成，这里可以仿照在github上面添加ssh-key一样的步骤添加。 6. 使用命令行下拉代码 进入cmd，进入存放代码的文件夹目录执行git命令 1、执行“git init” 初始化git环境，然后调用 2、执行“git clone 服务器代码路径”，开始下拉代码 备注：如果clone代码不成功，则把id_rsa文件放到git安装目录下的.ssh目录下，默认安装的话是 C:\Program Files (x86)\Git.ssh 7. 配置用户名和邮箱 要提交代码的时候，服务器上面显示是谁提交的代码，这里需要自己配置，配置的时候有两种方式，一种是全局配置（所有地方都用同样的用户名和邮箱），一种是针对各个工作目录自己配置。 进入cmd，进入代码工作目录，进行如下配置。全局配置：双引号也是命令内容 git config –global user.name “name”git config –global user.email “email”局部配置（命令行需要进入对应的代码工作目录）：双引号也是命令内容git config user.name “name”git config user.email “email” 8. 使用TortoiseGit来下拉代码配置1—&gt;生成 .ppk文件如果按找第2步中配置了相关环境变量，那么可以直接在cmd中打开puttygen(也可以到TortoiseGit的安装路径下找到C:\Program Files\TortoiseGit\bin\puttygen.exe) 点击下图中规定load加载私钥id_rsa，然后点击Save private key生成TortoiseGit需要使用的ppk文件（id_rsa.ppk） 9. 使用TortoiseGit来下拉代码配置2—&gt;配置TortoiseGit客户端打开TortoiseGit设置页面，配置相关参数如下：配置用户名和邮箱，配置服务器代码路径和上面得到的id_rsa.ppk路径，进入TortoiseGit的Settings页面，点击左边导航栏的Git目录，设置用户名和邮箱（Name, Email）,Name会在提交代码的时候显示出来，如果之前使用git config配置过，这里也可以不用配置的。 然后点击Git下的Remote菜单，添加一个origin远程仓库分之信息：Remote是为远程分之起个名字，URL是远程仓库地址，Putty是id_rsa.ppk文件路径，**至此就可以使用TortoiseGit正常工作了，可以试试pull，commit等功能。**]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Coding-搭建静态博客]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FHexo%2BCoding-%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[https://blog.paddings.cn/2016/04/30/blog/hexo-coding/ 早就想搭建一个自己的博客，是时候表演真正的技术了。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Http上传原理]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FHttp%E4%B8%8A%E4%BC%A0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Http上传需要用到multipart/form-data请求方式，Http协议原始方法不支持multipart/form-data请求，那这个请求自然就是由原始的请求方法拼装而成，具体规则如下： 1、multipart/form-data的本质上还是Post请求2、multipart/form-data与post方法的不同之处：请求头，请求体。3、multipart/form-data的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart/form-data，同时还需要规定一个内容分割符用于分割请求体中的多个post的内容，如文件内容和文本内容自然需要分割开来，不然接收方就无法正常解析和还原这个文件了。4、multipart/form-data的请求体也是一个字符串，不过和post的请求体不同的是它的构造方式，post是简单的name=value值连接，而multipart/form-data则是添加了分隔符等内容的构造体。抓包结果如下：Request URL:https://your_base_url/open/qiniu/imageRequest Method:POSTStatus Code:200 OK​Request HeadersAccept-Encoding:gzipConnection:Keep-AliveContent-Length:117276Content-Type:multipart/form-data; boundary=ed67c97e-2000-47de-9033-77aeb8df43d9Host:your_base_urltoken:794d5240-de2a-465b-9a5a-66f71f567acdUser-Agent:Dalvik/2.1.0 (Linux; U; Android 5.1.1; vivo X7 Build/LMY47V) app_name/1.5.0​Request Payload–ed67c97e-2000-47de-9033-77aeb8df43d9Content-Disposition: form-data; name=”file”; filename=”coin.jpg”Content-Type: image/jpgContent-Length: 117075–ed67c97e-2000-47de-9033-77aeb8df43d9– 可以看到Request Headers中包含了Accept-Encoding、Content-Length、Content-Type、Host、User-Agent等参数，OkHttp会自动生成boundary，无需手动编写规则；Request Payload中包含了具体的上传内容，Content-Disposition包含了上传文件名以及part参数key值，Content-Type指明了上传文件的后缀格式。 User-Agent一般都会重写，以其可以包含系统信息和用户自定义的信息，系统信息可以通过System.getProperty(“http.agent”)获得，然后再拼接上app独有的信息即可]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA配置JUnit进行单元测试]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FIDEA%E9%85%8D%E7%BD%AEJUnit%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前提条件安装JDK，并配置好环境变量工程已解决JUnit依赖关系（pom.xml） IDEA中JUnit配置IDEA自带一个JUnit插件，打开Settings窗口搜索junit，如图：图 1 该插件可以运行JUnit测试文件，但无法自动生成JUnit测试代码：图 2 如果需要自动生成测试代码，需要安装JUnitGenerator V2.0：图 3 安装后，在需要测试的类文件里点击code-&gt;Generate图 4 或者快捷键Alt+Insert，就会出现自动生成测试文件的选项：图 5 选择JUnit 4生成的测试文件@since位置Date可能存在乱码，可配置JUnit模板更改日期格式，不影响程序可直接忽略图 6 生成的测试文件可能位置不正确，可通过配置正确的输出路径解决：图 7 若工程路径如图：图 8 应把src目录设为Source Root图 9 把test目录设为Test Source Root图 10 注意事项IDEA自带的JUnit插件和JUnitGeneratorV2.0插件都要勾选上，若只勾选JUnit可能导致无法自动生成测试文件，若只勾选JUnitGenerator V2.0可能导致生成的测试文件无法运行图 11 参考链接IDEA社区版自动生成Junit测试类 IDEA中利用JUnit进行单元测试]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ-IDEA-插件推荐]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FIntelliJ-IDEA-%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[IntelliJ IDEA 插件推荐https://roc-wong.github.io/blog/2017/03/IntelliJ-IDEA-plugins.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ-IDEA-激活并配置jrebel热部署]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FIntelliJ-IDEA-%E6%BF%80%E6%B4%BB%E5%B9%B6%E9%85%8D%E7%BD%AEjrebel%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[http://www.toutiao.com/i6405125506206794242/ IDEA 注册码激活服务器：http://idea.imsxm.com/ LicenseServer.png使用方法Help-&gt;Register,弹出如上图界面。 点击License Server 填写地址。Activate 激活 OK JRebel 激活打开下面的网站，用Twitter或者Facebook登录，然后就能获得注册码了。然后在IDEA里面Help-&gt;JRebel-&gt;Activate，复制粘贴激活码就行了。https://my.jrebel.com/account/how-to-activate]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ配置SVN]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FIntelliJ%E9%85%8D%E7%BD%AESVN%2F</url>
    <content type="text"><![CDATA[导入SVN项目 通过TortoiseSVN在电脑创建一个代码仓库，导入相关项目； 打开IntelliJ ，如果未打开Version Control Integration单击打开intellij IDEA里面的svn功能【菜单栏VCS–&gt;Enable Version Control Integration】 配置SVN【菜单栏VCS—&gt;Checkout from VersionControl–&gt;subVersion】 配置intellij的svn访问路径为：svn://svn项目ip 在intellij IDEA里面重新check out仓库里刚上传的工程错误处理IntelliJ IDEA 13.1.2安装后，SVN checkout时候会出现如下错误：Cannot load supported formats: Cannot run program &quot;svn&quot;: CreateProcess error=2 究其原因，是SVN使用了命令行工具，如果本地没有SVN的命令行工具，则导致出错。 解决办法：1、安装客户端http://ncu.dl.sourceforge.net/project/tortoisesvn/1.8.7/Application/TortoiseSVN-1.8.7.25475-x64-svn-1.8.9.msihttp://jaist.dl.sourceforge.net/project/tortoisesvn/1.8.7/Language%20Packs/LanguagePack_1.8.7.25475-x64-zh_CN.msi 注意：安装时候必须选中command line 。。。这个选项。2、完成后配置IDEA这样，问题彻底解决！]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Intellij-IDEA官方帮助文档解释什么是Artifact(原文翻译)]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FIntellij-IDEA%E5%AE%98%E6%96%B9%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AFArtifact(%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91)%2F</url>
    <content type="text"><![CDATA[说明官方文档地址: https://www.jetbrains.com/help/idea/2016.2/working-with-artifacts.html翻译本只作为本人个人参考, 现提供给大家一并参考.因个人英语水平, 所以翻译的可能不是很好, 需要改进的地方还望懂的朋友提出以便本人加以修正.Artifact是什么? (What is an artifact?)Artifact是你的项目资产的一个集合, 将他们项目中的文件放在一起去测试, 部署或者描述你的软件解决方案, 又或是项目的一部分.例如是以编译的java class文件, 或者打包成java档案文件(jar包文件)的java应用, 一个web应用的文件夹(就是webcontent或myeclipse下的webroot)结构或者是一个web应用程序档案文件(war包文件)等.Arifact是可以是一份档案文件, 或者是一个文件夹的结构, 包含下列元素:一个或多个的项目模块编译输出(也就是类路径src下面的资源).模块依赖包含的lib包.资源文件的集合(web网页, 图片, 描述文件( descriptor files )等)其他的Artifact单独的文件, 目录或者档案(在部署构建artifacts的时候可以自己添加其他地方文件等) Note: 上面说的档案一般是压缩文件, 例如war包, jar包, ear包.Artifact的配置 (Working with artifact configurations)Artifact的生成与 Artifact的配置有关, Artifact是在 Project Structure(项目结构) 对话框中进行管理的.(File | Project Structure | Artifacts).Artifact配置关键的部分是 在输出布局选项卡 Output Layout tab. 指定 Artifact的结构和内容.译者注: 将项目中的东西组合在一起的一个过程, 例如eclipse里我们添加jar包是直接add to path. idea就是在要在modules和artifacts这里配置lib等一些其他的文件.构建Artifact (Building artifacts)你可以在Build | Build Artifacts处构建你自己的 Artifact.你也可以通过执行 run/debug的配置来构建一个Artifact.在对应的 run/debug配置中, 在运行之前添加一个Build artifact 的任务到任务列表. 当你执行 run/debug配置的时候Artifact会自动构建. (Run | Run or Run | Debug)在run/debug配置中包含一个构建Artifact的任务是有意义的, run/debug配置会以某种方式使用相应的artifacts.译者注: 上面这句话是说, 在我们添加了一个运行服务器的配置的时候可以在Deployement这个选项卡那里添加一个artifacts, 如果有已存在的artifacts, 那么会直接添加进来, 如果没有则会自动带你到Build | Build Artifacts这个地方去让你构建artifacts.例如在一个应用服务器中启动一个打包成jar包中的artifact,或部署一个WAR/EAR artifact.默认情况下, 当Artifact构建时, 它会被放在out/artifacts/文件夹.运行JAR Artifact (Running JAR artifacts)运行一个打包成JAR的java应用程序, IDEA提供了一些JAR应用运行配置(JAR Application run configurations), 创建这样的运行配置:打开Run/Debug配置对话框(Run | Edit Configurations)单击 + 号 , 然后选择JAR应用. 部署Artifact到应用服务器和云平台 (Deploying artifacts to application servers and cloud platforms)许多artifact的格式(例如 WAR, 分解的WAR(Exploded WAR), 分解的EAR)都适合部署到应用服务器和云平台.以下是如何部署一个这样的artifact:在一个服务器或云服务器的run/debug configuration中, 指定需要部署的artifact(使用部署选项卡或区域(Use the Deployment tab or field.))在run/debug工具窗口, 或应用服务器中执行run/debug配置或使用部署命令]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA判断一个URL是否有效]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FJAVA%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AAURL%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88%2F</url>
    <content type="text"><![CDATA[1234567try &#123; url = new URL(&quot;http://127.0.0.1/sj/user/getUser&quot;); in = url.openStream(); &#125; catch (Exception e1) &#123; System.out.println(&quot;连接打不开!&quot;); url = null; &#125; 12345678910111213141516171819202122232425262728293031323334/** * 功能：检测当前URL是否可连接或是否有效, * 描述：最多连接网络 3 次, 如果 3 次都不成功，视为该地址不可用 * @param urlStr 指定URL网络地址 * @return URL */ public synchronized String isConnect(String urlStr) &#123; int counts = 0; retu = &quot;&quot;; if (urlStr == null || urlStr.length() &lt;= 0) &#123; return null; &#125; while (counts &lt; StaticConstant.REQUEST_COUNT) &#123; long start = 0; try &#123; url = new URL(urlStr); start = System.currentTimeMillis(); con = (HttpURLConnection) url.openConnection(); state = con.getResponseCode(); log.info(&quot;请求断开的URL一次需要：&quot;+(System.currentTimeMillis()-start)+&quot;毫秒&quot;); if (state == 200) &#123; retu = &quot;ok&quot;; log.info(urlStr+&quot;--可用&quot;); &#125; break; &#125;catch (Exception ex) &#123; counts++; log.info(&quot;请求断开的URL一次需要：&quot;+(System.currentTimeMillis()-start)+&quot;毫秒&quot;); log.info(&quot;连接第 &quot;+counts+&quot; 次，&quot;+urlStr+&quot;--不可用&quot;); continue; &#125; &#125; return retu; &#125;]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-8-Lambda--表达式（lambda-expressions）-我的理解]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FJava-8-Lambda--%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88lambda-expressions%EF%BC%89-%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[lambda表达式（lambda expressions）是函数式编程。 百度百科：“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。 维基百科：函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数)计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 背景不过有些 Java 对象只是对单个函数的封装。例如下面这个典型用例：Java API 中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：123public interface ActionListener &#123; void actionPerformed(ActionEvent e);&#125; 这里并不需要专门定义一个类来实现 ActionListener，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：12345button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; ui.dazzle(e.getModifiers()); &#125;&#125;); 我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的 选择。大多数回调接口都拥有这个特征：比如 Runnable 接口和 Comparator 接口。我们把这些只拥有一个方法的接口称为 函数式接口。（之前它们被称为 SAM类型，即 单抽象方法类型（Single Abstract Method）） 我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个 Object 已经提供的方法，比如 toString()，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过 @FunctionalInterface 注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。 lamdba表达式的目的：解决匿名内部类使用的问题： 语法过于冗余 匿名类中的 this 和变量名容易使人产生误解 类型载入和实例创建语义不够灵活 无法捕获非 final 的局部变量 无法对控制流进行抽象匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面 ActionListener 的例子里的五行代码中仅有一行在做实际工作。 lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。 下面是一些lambda表达式： (int x, int y) -&gt; x + y() -&gt; 42(String s) -&gt; { System.out.println(s); } 第一个 lambda 表达式接收 x 和 y 这两个整形参数并返回它们的和；第二个 lambda 表达式不接收参数，返回整数 ‘42’；第三个 lambda 表达式接收一个字符串并把它打印到控制台，不返回值。 lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式：表达式会被执行然后返回执行结果。 语句块：语句块中的语句会被依次执行，就像方法中的语句一样—— return 语句会把控制权交给匿名方法的调用者 break 和 continue 只能在循环中使用 如果函数体有返回值，那么函数体内部的每一条路径都必须返回值表达式函数体适合小型 lambda 表达式，它消除了 return 关键字，使得语法更加简洁。 Java8中，想要使用Lambda表达式，需要使用一个全新的操作符”-&gt;”该操作符被称为”Lambda操作符”，它把表达式分为了左右两部分。左边：Lambda中所使用的参数列表右边：Lambda所要执行的操作。 Example 1：无参数，无返回值的写法Example 2：有参数，无返回值的写法Example 3：有参数（多个），有返回值的写法 java.util.functionJava SE 8中增加了一个新的包：java.util.function，它里面包含了常用的函数式接口，例如： Predicate——接收 T 并返回 booleanConsumer——接收 T，不返回值Function——接收 T，返回 RSupplier——提供 T 对象（例如工厂），不接收值UnaryOperator——接收 T 对象，返回 TBinaryOperator——接收两个 T，返回 T 类型需要注意的是，函数式接口的名称并不是 lambda 表达式的一部分。那么问题来了，对于给定的 lambda 表达式，它的类型是什么。编译器负责推导 lambda 表达式类型。它利用 lambda 表达式所在上下文 所期待的类型 进行推导，这个 被期待的类型 被称为 目标类型。lambda 表达式只能出现在目标类型为函数式接口的上下文中。当然，lambda 表达式对目标类型也是有要求的。编译器会检查 lambda 表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda 表达式才可以被赋给目标类型 T： T 是一个函数式接口lambda 表达式的参数和 T 的方法参数在数量和类型上一一对应lambda 表达式的返回值和 T 的方法返回值相兼容（Compatible)lambda 表达式内所抛出的异常和 T 的方法 throws 类型相兼容 方法引用（Method references）lambda 表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在 已有的 方法上实现同样的特性。对于静态方法引用，我们需要在类名和方法名之间加入 :: 分隔符，例如 Integer::sum其实是lambda表达式的一个简化写法，所引用的方法其实是lambda表达式的方法体实现，语法也很简单，左边是容器（可以是类名，实例名），中间是”::”，右边是相应的方法名。如下所示：1ObjectReference::methodName Comparator byName = Comparator.comparing(Person::getName); ```这里的 Person::getName 可以被看作为 lambda 表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。方法引用有很多种，它们的语法如下 静态方法引用：ClassName::methodName实例上的实例方法引用：instanceReference::methodName超类上的实例方法引用：super::methodName类型上的实例方法引用：ClassName::methodName构造方法引用：Class::new数组构造方法引用：TypeName[]::new]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-8新特性]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FJava-8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[“Java并没有没落，人们很快就会发现这一点” java 8 简明教程https://wizardforcel.gitbooks.io/modern-java/content/ch1.html本教程将带领你一步一步地认识这门语言的新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和重复注解。看完这篇教程后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。 java lamadba 十个例子http://www.importnew.com/16436.html java lamadba 快速启动http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html#summary]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-8的新特性—终极版文章]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FJava-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E7%BB%88%E6%9E%81%E7%89%88%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Java 8的新特性—终极版http://ifeve.com/java-8-features-tutorial/Java 8 特性 – 终极手册http://www.jianshu.com/p/5b800057f2d8 Java 8的新特性—终极版 深入理解 Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）深入理解 Java 8 Lambda（类库篇——Streams API，Collector 和并行）Java8 Lambda使用与原理https://luyiisme.github.io/2017/01/21/java8-lambda/ Java 8 lambda 最佳实践https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20lambda%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java-api-1-8-中文-帮助文档]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FJava-api-1-8-%E4%B8%AD%E6%96%87-%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[java 1.6 帮助文档中文链接：http://download.csdn.net/detail/qw599186875/9608735英文Java1.8 帮助文档英文中文 – 谷歌版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-google/下载链接：http://download.csdn.net/detail/qw599186875/9802192中文 – 必应版下载链接：http://download.csdn.net/detail/qw599186875/9839280中文 – 有道版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-youdao/下载链接：http://download.csdn.net/detail/qw599186875/9608721中文 – 百度版在线版: https://blog.fondme.cn/apidoc/jdk-1.8-baidu/下载链接：http://download.csdn.net/detail/qw599186875/9608724]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法解析.html]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FMarkDown%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[MarkDown语法解析 body { margin: 0; font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif; font-size: 14px; line-height: 20px; color: #777; background-color: white; } .container { width: 700px; margin-right: auto; margin-left: auto; } .post { font-family: Georgia, "Times New Roman", Times, "SimSun", serif; position: relative; padding: 70px; bottom: 0; overflow-y: auto; font-size: 16px; font-weight: normal; line-height: 25px; color: #515151; } .post h1{ font-size: 50px; font-weight: 500; line-height: 60px; margin-bottom: 40px; color: inherit; } .post p { margin: 0 0 35px 0; } .post img { border: 1px solid #D9D9D9; } .post a { color: #28A1C5; } MarkDown语法解析 Markdown 的优点如下： 1.纯文本，所以兼容性极强，可以用所有文本编辑器打开。 2.让你专注于文字而不是排版。 3.格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 4.Markdown 的标记语法有极好的可读性。 标题这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上#即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加#即可，标题字号相应降低。例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：#和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。你可以你的编辑器中尝试输入这六级标题，可以参考下方的截图： 一级标题至六级标题 列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上-就可以了，例如： -文本1 -文本2 -文本3 如果你希望有序列表，也可以在文字前面加上1.2.3.就可以了，例如： 1.文本1 2.文本2 3.文本3 注：-、1.和文本之间要保留一个字符的空格。列表案例截图如下： 链接和图片在 Markdown 中，插入链接不需要其他按钮，你只需要使用[显示文本](链接地址)这样的语法即可，例如：[简书](http://www.jianshu.com)在 Markdown 中，插入图片不需要其他按钮，你只需要使用![](图片链接地址)这样的语法即可，例如：![](http://upload-images.jianshu.io/upload_images/259-0ad0d0bfc1c608b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)注：插入图片的语法和链接的语法很像，只是前面多了一个！,中括号[]中的文字会变成图片的标注。插入链接和图片的案例截图： 引用在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上&gt;就好了，例如：&gt;一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。注：&gt;和文本之间要保留一个字符的空格。最终显示的就是：一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。引用的案例截图： 引用的案例截图 粗体和斜体Markdown 的粗体和斜体也非常简单，用两个*包含一段文本就是粗体的语法，用一个*包含一段文本就是斜体的语法。例如：*一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。最终显示的就是下文，其中「一盏灯」是斜体，「一简书」是粗体：一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。粗体和斜体的案例截图： 代码引用需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。代码引用的案例截图： 代码引用的案例截图 表格 显示链接中带括号的图片 代码如下:![][1][1]:http://latex.codecogs.com/gif.latex?\prod%20\(n_{i}\)+1结语以上几种格式是比较常用的格式，所以我们针对这些语法做了比较详细的说明。除这些之外，Markdown 还有其他语法，如想了解和学习更多，可以参考这篇『Markdown 语法说明』。强烈建议您现在就立马用 Markdown 写一篇文章吧，体会一下 Markdown 的优雅之处！原文链接：[http://www.jianshu.com/p/q81RER]]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Servlet容器Tomcat中web-xml中url-pattern的配置详解[附带源码分析]]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FServlet%E5%AE%B9%E5%99%A8Tomcat%E4%B8%ADweb-xml%E4%B8%ADurl-pattern%E7%9A%84%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%5B%E9%99%84%E5%B8%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5D%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/fangjian0423/p/servletContainer-tomcat-urlPattern.html#springmvc]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sping-系列框架官方参考文档（全）]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FSping-%E7%B3%BB%E5%88%97%E6%A1%86%E6%9E%B6%E5%AE%98%E6%96%B9%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%EF%BC%88%E5%85%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/index.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-架构分析，代码解读]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FSpringMVC-%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%8C%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[有人gitbook整理了个不错的短书：SpringMVC源码分析迷你书https://fangjian0423.gitbooks.io/springmvc-source-minibook/content/index.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC源码分析迷你书]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FSpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%B7%E4%BD%A0%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[https://fangjian0423.gitbooks.io/springmvc-source-minibook/content/index.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring集成junit]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2FSpring%E9%9B%86%E6%88%90junit%2F</url>
    <content type="text"><![CDATA[加入依赖包1234567891011&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 增加注解@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = “classpath:spring/spring-safety.xml”)]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记整理]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Fgit%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考文章http://www.cnblogs.com/popfisher/p/5466174.html安装git安装git tortoise设置用户名和密码 $ git config –global user.name “xxx”$ git config –global user.email “xxx@xx.com” 生成key ssh-keygen -t rsa -C “email@email.com” 配置Git Tortoise 私钥 如果按找第2步中配置了相关环境变量，那么可以直接在cmd中打开puttygen(也可以到TortoiseGit的安装路径下找到C:\Program Files\TortoiseGit\bin\puttygen.exe)点击下图中规定load加载私钥id_rsa，然后点击Save private key生成TortoiseGit需要使用的ppk文件（id_rsa.ppk） 9. 使用TortoiseGit来下拉代码配置2—&gt;**配置TortoiseGit客户端 打开TortoiseGit设置页面，配置相关参数如下：配置用户名和邮箱，配置服务器代码路径和上面得到的id_rsa.ppk路径，进入TortoiseGit的Settings页面，点击左边导航栏的Git目录，设置用户名和邮箱（Name, Email）,Name会在提交代码的时候显示出来，如果之前使用git config配置过，这里也可以不用配置的。然后点击Git下的Remote菜单，添加一个origin远程仓库分之信息：Remote是为远程分之起个名字，URL是远程仓库地址，Putty是id_rsa.ppk文件路径 至此就可以使用TortoiseGit正常工作了，可以试试pull，commit等功能**]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[https-页面中引入-http-资源的解决方式]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Fhttps-%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%BC%95%E5%85%A5-http-%E8%B5%84%E6%BA%90%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[https://segmentfault.com/a/1190000004200361 而且如果在一个 https 页面里动态的引入 http 资源，比如引入一个 js 文件，会被直接 block 掉的。Chrome v21 之后，在 SSL 加密页面 embed 非 SSL 的 Flash 资源也会被默默的屏蔽掉，只留下一句 console 报告。解决方式 相对协议如果你的网站同时准备了 https 资源和 http 资源，那么，可以使用相对协议可以帮助你实现当网站引入的都是 http 资源，网站域名更换为 https 后的无缝切换。具体使用方法为：1&lt;img src=&quot;//domain.com/img/logo.png&quot;&gt; 简而言之，就是将URL的协议（http、https）去掉，只保留//及后面的内容。这样，在使用https的网站中，浏览器会通过https请求URL，否则就通过http发送请求。附注：如果是浏览本地文件，浏览器通过file://协议发送请求，导致请求失败，因此本地测试最好是搭建一个本地服务器。 HTML5 Boilerplate 使用相对协议请求 Google CDN 中的 jQuery ，使用方式为：12&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt;!window.jQuery &amp;&amp; document.write(unescape(&apos;%3Cscript src=&quot;js/libs/jquery-1.4.2.js&quot;%3E%3C/script%3E&apos;))&lt;/script&gt; 上面的例子中除了引用 Google CDN 中的文件外，还添加了一个本地 jQuery 链接，以便连接 Google CDN 失败后，使用本地副本。代码判断过程为：首先检查 jquery 对象是否存在，如果存在，证明 Google CDN 运行正常； 如果不存在，则说明连接 Google CDN 失败，引入本地 jQuery 库。 本猿认为，在国内相对特殊的网络环境中，Google CDN 请求缓慢甚至失败常有，因此不推荐引用 Google CDN 托管的各种库。即便有备用链接，浏览器还是会多次尝试请求 Google CDN 中的文件，这个过程可谓漫长，严重影响页面载入速度。 使用 iframe使用 iframe 的方式引入 http 资源，比如在 https 里面播放优酷的视频，我们可以先在一个 http 的页面里播放优酷视频，然后将这个页面嵌入到 https 页面里就可以了。另外一个典型的例子是在 https 页面里通过 Ajax 的方式请求 http 资源，Chrome 是不允许直接 Ajax 请求 http 的。如果两个页面的内容都可以控制的话，当前窗口可以 iframe 窗口进行通信。其他用法这个小技巧同样适用于 CSS ：.omg { background: url(//websbestgifs.net/kittyonadolphin.gif); } 附注：或@import引入样式表时使用相对协议，IE7、IE8 会下载文件两次。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[angular系列教程看这里]]></title>
    <url>%2F2017%2F11%2F15%2FAngular%2F%E8%A7%A3%E9%87%8A%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[angular教程系列文章，由于angular语法和makedown语法冲突，写起来费劲。请移步看这里。 http://www.jianshu.com/nb/15749764]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux-tomcat配置https]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Flinux-tomcat%E9%85%8D%E7%BD%AEhttps%2F</url>
    <content type="text"><![CDATA[创建.keystore123456789101112131415161718192021[root@centos apache-tomcat-6.0.37]# keytool -genkey -alias tomcat -keyalg RSA -keystore /root/tomcat/apache-tomcat-6.0.37/conf/.keystore输入keystore密码： 再次输入新密码: 您的名字与姓氏是什么？ [Unknown]： free4lab您的组织单位名称是什么？ [Unknown]： free4lab您的组织名称是什么？ [Unknown]： free4lab您所在的城市或区域名称是什么？ [Unknown]： beijing您所在的州或省份名称是什么？ [Unknown]： beijing该单位的两字母国家代码是什么 [Unknown]： CNCN=free4lab, OU=free4lab, O=free4lab, L=beijing, ST=beijing, C=CN 正确吗？ [否]： y输入&lt;tomcat&gt;的主密码 （如果和 keystore 密码相同，按回车）： [root@centos apache-tomcat-6.0.37]# cat conf/.keystore 然后修改tomcat配置文件server.xml123&lt;Connector port=&quot;8800&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; clientAuth=&quot;false&quot; keystoreFile=&quot;/opt/tomcat/conf/.keystore&quot; keystorePass=&quot;wewell&quot; sslProtocol=&quot;TLS&quot; /&gt; 这样浏览器访问就相对安全了，浏览器和服务端进行了非对称加密的握手，然后协商对称加密的密钥，然后进行相对快速的对称加密传输。即时密文在网络传输中被截获，因为无法获知对称密钥，所以这个http api就是安全的！]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[log4j-properties配置详解]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Flog4j-properties%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[````1. 配置文件Log4J配置文件的基本格式如下： #配置根Loggerlog4j.rootLogger = [ level ] , appenderName1 , appenderName2 , … #配置日志信息输出目的地Appenderlog4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.optionN = valueN #配置日志信息的格式（布局）log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.optionN = valueN其中 [level] 是日志输出级别，共有5级：** FATAL 0ERROR 3WARN 4INFO 6DEBUG 7 Appender 为日志输出目的地，Log4j提供的appender有以下几种：org.apache.log4j.ConsoleAppender（控制台），org.apache.log4j.FileAppender（文件），org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）Layout：日志输出格式，Log4j提供的layout有以下几种：org.apache.log4j.HTMLLayout（以HTML表格形式布局），org.apache.log4j.PatternLayout（可以灵活地指定布局模式），org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）打印参数: Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，如下: %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22 ： 10 ： 28， 921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 2. 在代码中初始化Logger: 1）在程序中调用BasicConfigurator.configure()方法：给根记录器增加一个ConsoleAppender，输出格式通过PatternLayout设为“%-4r [%t] %-5p %c %x - %m%n”，还有根记录器的默认级别是Level.DEBUG. 2）配置放在文件里，通过命令行参数传递文件名字，通过PropertyConfigurator.configure(args[x])解析并配置；3）配置放在文件里，通过环境变量传递文件名等信息，利用log4j默认的初始化过程解析并配置；4）配置放在文件里，通过应用服务器配置传递文件名等信息，利用一个特殊的servlet来完成配置。3. 为不同的 Appender 设置日志输出级别：当调试系统时，我们往往注意的只是异常级别的日志输出，但是通常所有级别的输出都是放在一个文件里的，如果日志输出的级别是BUG！？那就慢慢去找吧。这时我们也许会想要是能把异常信息单独输出到一个文件里该多好啊。当然可以，Log4j已经提供了这样的功能，我们只需要在配置中修改Appender的Threshold 就能实现,比如下面的例子：[配置文件] set log levelslog4j.rootLogger = debug , stdout , D , E 输出到控制台log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n 输出到日志文件log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG ## 输出DEBUG级别以上的日志log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n 保存异常信息到单独文件log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = logs/error.log ## 异常日志文件名log4j.appender.D.Append = truelog4j.appender.D.Threshold = ERROR ## 只输出ERROR级别以上的日志!!!log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n[代码中使用] public class TestLog4j { public static void main(String[] args) { PropertyConfigurator.configure( &quot; D:/Code/conf/log4j.properties &quot; ); Logger logger = Logger.getLogger(TestLog4j. class ); logger.debug( &quot; debug &quot; ); logger.error( &quot; error &quot; ); } }运行一下，看看异常信息是不是保存在了一个单独的文件error.log中log4j.properties 使用一.参数意义说明输出级别的种类ERROR、WARN、INFO、DEBUGERROR 为严重错误 主要是程序的错误WARN 为一般警告，比如session丢失INFO 为一般要显示的信息，比如登录登出DEBUG 为程序的调试信息配置日志信息输出目的地log4j.appender.appenderName = fully.qualified.name.of.appender.class1.org.apache.log4j.ConsoleAppender（控制台）2.org.apache.log4j.FileAppender（文件）3.org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）4.org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）5.org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）配置日志信息的格式log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class1.org.apache.log4j.HTMLLayout（以HTML表格形式布局），2.org.apache.log4j.PatternLayout（可以灵活地指定布局模式），3.org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），4.org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）控制台选项Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。Target=System.err：默认情况下是：System.out,指定输出控制台FileAppender 选项Threshold=DEBUF:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。RollingFileAppender 选项Threshold=DEBUG:指定日志消息的输出最低层次。ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。File=mylog.txt:指定消息输出到mylog.txt文件。Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。MaxBackupIndex=2:指定可以产生的滚动文件的最大数。log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n日志信息格式中几个符号所代表的含义： -X号: X信息输出时左对齐； %p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, %d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %r: 输出自应用启动到输出该log信息耗费的毫秒数 %c: 输出日志信息所属的类目，通常就是所在类的全名 %t: 输出产生该日志事件的线程名 %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main (TestLog4.java:10) %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 %%: 输出一个”%”字符 %F: 输出日志消息产生时所在的文件名称 %L: 输出代码中的行号 %m: 输出代码中指定的消息,产生的日志具体信息 %n: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行 可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： 1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-“号指定左对齐。 3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。 4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边较远输出的字符截掉。二.文件配置Sample1log4j.rootLogger=DEBUG,A1,R#log4j.rootLogger=INFO,A1,R# ConsoleAppender 输出log4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%c]-[%p] %m%n# File 输出 一天一个文件,输出路径可以定制,一般在根路径下log4j.appender.R=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.R.File=blog_log.txtlog4j.appender.R.MaxFileSize=500KBlog4j.appender.R.MaxBackupIndex=10log4j.appender.R.layout=org.apache.log4j.PatternLayoutlog4j.appender.R.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c] [%p] - %m%n文件配置Sample2下面给出的Log4J配置文件实现了输出到控制台，文件，回滚文件，发送日志邮件，输出到数据库日志表，自定义标签等全套功能。log4j.rootLogger=DEBUG,CONSOLE,A1,im #DEBUG,CONSOLE,FILE,ROLLING_FILE,MAIL,DATABASElog4j.addivity.org.apache=true################### # Console Appender ################### log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.Threshold=DEBUG log4j.appender.CONSOLE.Target=System.out log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout log4j.appender.CONSOLE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n #log4j.appender.CONSOLE.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD] n%c[CATEGORY]%n%m[MESSAGE]%n%n##################### # File Appender ##################### log4j.appender.FILE=org.apache.log4j.FileAppender log4j.appender.FILE.File=file.log log4j.appender.FILE.Append=false log4j.appender.FILE.layout=org.apache.log4j.PatternLayout log4j.appender.FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n # Use this layout for LogFactor 5 analysis######################## # Rolling File ######################## log4j.appender.ROLLING_FILE=org.apache.log4j.RollingFileAppender log4j.appender.ROLLING_FILE.Threshold=ERROR log4j.appender.ROLLING_FILE.File=rolling.log log4j.appender.ROLLING_FILE.Append=true log4j.appender.ROLLING_FILE.MaxFileSize=10KB log4j.appender.ROLLING_FILE.MaxBackupIndex=1 log4j.appender.ROLLING_FILE.layout=org.apache.log4j.PatternLayout log4j.appender.ROLLING_FILE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n#################### # Socket Appender #################### log4j.appender.SOCKET=org.apache.log4j.RollingFileAppender log4j.appender.SOCKET.RemoteHost=localhost log4j.appender.SOCKET.Port=5001 log4j.appender.SOCKET.LocationInfo=true # Set up for Log Facter 5 log4j.appender.SOCKET.layout=org.apache.log4j.PatternLayout log4j.appender.SOCET.layout.ConversionPattern=[start]%d{DATE}[DATE]%n%p[PRIORITY]%n%x[NDC]%n%t[THREAD]%n%c[CATEGORY]%n%m[MESSAGE]%n%n######################## # Log Factor 5 Appender ######################## log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000######################## # SMTP Appender ####################### log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender log4j.appender.MAIL.Threshold=FATAL log4j.appender.MAIL.BufferSize=10 log4j.appender.MAIL.From=chenyl@yeqiangwei.comlog4j.appender.MAIL.SMTPHost=mail.hollycrm.com log4j.appender.MAIL.Subject=Log4J Message log4j.appender.MAIL.To=chenyl@yeqiangwei.comlog4j.appender.MAIL.layout=org.apache.log4j.PatternLayout log4j.appender.MAIL.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n######################## # JDBC Appender ####################### log4j.appender.DATABASE=org.apache.log4j.jdbc.JDBCAppender log4j.appender.DATABASE.URL=jdbc:mysql://localhost:3306/test log4j.appender.DATABASE.driver=com.mysql.jdbc.Driver log4j.appender.DATABASE.user=root log4j.appender.DATABASE.password= log4j.appender.DATABASE.sql=INSERT INTO LOG4J (Message) VALUES (‘[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n’) log4j.appender.DATABASE.layout=org.apache.log4j.PatternLayout log4j.appender.DATABASE.layout.ConversionPattern=[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%nlog4j.appender.A1=org.apache.log4j.DailyRollingFileAppender log4j.appender.A1.File=SampleMessages.log4j log4j.appender.A1.DatePattern=yyyyMMdd-HH’.log4j’ log4j.appender.A1.layout=org.apache.log4j.xml.XMLLayout################### #自定义Appender ################### log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppenderlog4j.appender.im.host = mail.cybercorlin.net log4j.appender.im.username = username log4j.appender.im.password = password log4j.appender.im.recipient = corlin@yeqiangwei.comlog4j.appender.im.layout=org.apache.log4j.PatternLayout log4j.appender.im.layout.ConversionPattern =[framework] %d - %c -%-4r [%t] %-5p %c %x - %m%n三.高级使用实验目的： 1.把FATAL级错误写入2000NT日志 2. WARN，ERROR，FATAL级错误发送email通知管理员 3.其他级别的错误直接在后台输出实验步骤： 输出到2000NT日志 1.把Log4j压缩包里的NTEventLogAppender.dll拷到WINNT\SYSTEM32目录下 2.写配置文件log4j.properties# 在2000系统日志输出 log4j.logger.NTlog=FATAL, A8 # APPENDER A8 log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender log4j.appender.A8.Source=JavaTest log4j.appender.A8.layout=org.apache.log4j.PatternLayout log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n3.调用代码： Logger logger2 = Logger.getLogger(“NTlog”); //要和配置文件中设置的名字相同 logger2.debug(“debug!!!”); logger2.info(“info!!!”); logger2.warn(“warn!!!”); logger2.error(“error!!!”); //只有这个错误才会写入2000日志 logger2.fatal(“fatal!!!”);发送email通知管理员： 1. 首先下载JavaMail和JAF, http://java.sun.com/j2ee/ja/javamail/index.html http://java.sun.com/beans/glasgow/jaf.html 在项目中引用mail.jar和activation.jar。 2. 写配置文件 # 将日志发送到email log4j.logger.MailLog=WARN,A5 # APPENDER A5 log4j.appender.A5=org.apache.log4j.net.SMTPAppender log4j.appender.A5.BufferSize=5 log4j.appender.A5.To=chunjie@yeqiangwei.com log4j.appender.A5.From=error@yeqiangwei.com log4j.appender.A5.Subject=ErrorLog log4j.appender.A5.SMTPHost=smtp.263.net log4j.appender.A5.layout=org.apache.log4j.PatternLayout log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n 3.调用代码： //把日志发送到mail Logger logger3 = Logger.getLogger(“MailLog”); logger3.warn(“warn!!!”); logger3.error(“error!!!”); logger3.fatal(“fatal!!!”);在后台输出所有类别的错误： 1. 写配置文件 # 在后台输出 log4j.logger.console=DEBUG, A1 # APPENDER A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n 2．调用代码 Logger logger1 = Logger.getLogger(“console”); logger1.debug(“debug!!!”); logger1.info(“info!!!”); logger1.warn(“warn!!!”); logger1.error(“error!!!”); logger1.fatal(“fatal!!!”);——————————————————————– 全部配置文件：log4j.properties # 在后台输出 log4j.logger.console=DEBUG, A1 # APPENDER A1 log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n# 在2000系统日志输出 log4j.logger.NTlog=FATAL, A8 # APPENDER A8 log4j.appender.A8=org.apache.log4j.nt.NTEventLogAppender log4j.appender.A8.Source=JavaTest log4j.appender.A8.layout=org.apache.log4j.PatternLayout log4j.appender.A8.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n# 将日志发送到email log4j.logger.MailLog=WARN,A5 # APPENDER A5 log4j.appender.A5=org.apache.log4j.net.SMTPAppender log4j.appender.A5.BufferSize=5 log4j.appender.A5.To=chunjie@yeqiangwei.com log4j.appender.A5.From=error@yeqiangwei.com log4j.appender.A5.Subject=ErrorLog log4j.appender.A5.SMTPHost=smtp.263.net log4j.appender.A5.layout=org.apache.log4j.PatternLayout log4j.appender.A5.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n全部代码：Log4jTest.java / 创建日期 2003-11-13 / package edu.bcu.Bean; import org.apache.log4j.; //import org.apache.log4j.nt.; //import org.apache.log4j.net.; /* @author yanxu */ public class Log4jTest { public static void main(String args[]) { PropertyConfigurator.configure(“log4j.properties”); //在后台输出 Logger logger1 = Logger.getLogger(“console”); logger1.debug(“debug!!!”); logger1.info(“info!!!”); logger1.warn(“warn!!!”); logger1.error(“error!!!”); logger1.fatal(“fatal!!!”);//在NT系统日志输出 Logger logger2 = Logger.getLogger(“NTlog”); //NTEventLogAppender nla = new NTEventLogAppender(); logger2.debug(“debug!!!”); logger2.info(“info!!!”); logger2.warn(“warn!!!”); logger2.error(“error!!!”); //只有这个错误才会写入2000日志 logger2.fatal(“fatal!!!”);//把日志发送到mail Logger logger3 = Logger.getLogger(“MailLog”); //SMTPAppender sa = new SMTPAppender(); logger3.warn(“warn!!!”); logger3.error(“error!!!”); logger3.fatal(“fatal!!!”); } }]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[log4j-的使用和配置简介]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Flog4j-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[12345 log4jlog4j1.2.17 级别OFF 关闭所有日志记录FATAL 严重的错误事件将会导致应用程序的退出ERROR 虽然发生错误事件，但仍然不影响系统的继续运行。WARN 会出现潜在错误的情形。INFO 消息在粗粒度级别上突出强调应用程序的运行过程。DEBUG 指出细粒度信息事件对调试应用程序是非常有帮助的ALL 开启所有的日志记录 级别优先级OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; ALL使用在pom.xml 中添加依赖在项目的中添加log4j.properties 配置log4.rootLoggerlog4j.rootLogger=日志级别，appender1, appender2, ….注意，rootLogger默认是对整个工程生效注意，如果只想对某些包操作，那么：log4j.logger.com.hutu=info, stdout，表示该日志对package com.hutu生效注意，这样做可以区分dev/线上，也可以减小性能影响：if(log.isDebugEnabled()){log.debug();} 基础配置Appender属性描述 layoutAppender 使用 Layout 对象和与之关联的模式来格式化日志信息。 target目的地可以是控制台、文件，或依赖于 appender 的对象 level级别用来控制过滤日志信息 thresholdAppender 可脱离于日志级别定义一个阀值级别，Appender 对象会忽略所有级别 低于阀值级别的日志。 filterFilter 对象可在级别基础之上分析日志信息，来决定 Appender 对象是否处理或忽 略一条日志记录。 所有appender官方文档 AppenderSkeletonAsyncAppenderConsoleAppender输出到控制台1234567 log4j.rootLogger = debug , stdout , D , E 输出到控制台log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = %d{ABSOLUTE} %5p %c{ 1 }:%L - %m%n DailyRollingFileAppender每天产生一个文件ExternallyRolledFileAppenderFileAppender文件JDBCAppender将日志信息保存到数据库中JMSAppenderLF5AppenderNTEventLogAppenderNullAppenderRollingFileAppender文件大小到达指定大小,则新创建个文件SMTPAppenderSocketAppenderSocketHubAppenderSyslogAppenderTenetAppenderWriterAppender将日志信息以流格式发送到任意指定的地方LayoutLayoutsDateLayoutHTMLLayoutPatternLayoutSimpleLayoutXMLLayout日志格式化模式转换符转换字符含义 c使用它为输出日志分类,比如对于分类”a.b.c”,模式%c{2}会输出”b.c” C使用它输出发起记录日志请求的类的全名。比如对于类”cn.fondme.logger.XXClass”,模式%C{1}会输出”XXClass” d使用它输出记录日志的日期,比如%d{HH:mm:ss} F在记录日志时,使用它输出文件名 I用它输出生成日志的调用者的地域信息。 L使用它输出发起日志请求的行号。 m使用它输出和日志事件关联的，由应用提供的信息。 M使用它输出发起日志请求的方法名。 n输出平台相关的换行符。 p输出日志事件的优先级。 r使用它输出从构建布局到生成日志事件所花费的时间，以毫秒为单位。 t输出生成日志事件的线程名。 x输出和生成日志事件线程相关的 NDC (嵌套诊断上下文)。 X该字符后跟 MDC 键，比如 X{clientIP} 会输出保存在 MDC 中键 clientIP 对应的值。 %百分号， %% 会输出一个 %。 格式修饰符格式修饰符左对齐最小宽度最大宽度注释 %20c否20无如果列名少于 20 个字符，左边使用空格补齐 %-20c是20无如果列名少于 20 个字符，右边使用空格补齐。 %.30c不适用无30如果列名长于 30 个字符，从开头剪除。 %20.30c否2030如果列名少于 20 个字符，左边使用空格补齐，如果列名长于 30 个字 符，从开头剪除。 %-20.30c是2030如果列名少于 20 个字符，右边使用空格补齐，如果列名长于 30 个字 符，从开头剪除。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven的pom-xml文件详解]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2Fmaven%E7%9A%84pom-xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd &quot;&gt; &lt;!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!-- 被继承的父项目的构件标识符 --&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;!-- 被继承的父项目的全球唯一标识符 --&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;!-- 被继承的父项目的版本 --&gt; &lt;version&gt;xxx&lt;/version&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。 Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置）， 然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath&gt;xxx&lt;/relativePath&gt; &lt;/parent&gt; &lt;!-- 声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的， 这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt; 4.0.0 &lt;/modelVersion&gt; &lt;!-- 项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID 和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven 为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;!-- 项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt; jar &lt;/packaging&gt; &lt;!-- 项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt; 1.0-SNAPSHOT &lt;/version&gt; &lt;!-- 项目的名称, Maven产生的文档用 --&gt; &lt;name&gt; xxx-maven &lt;/name&gt; &lt;!-- 项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt; http://maven.apache.org &lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略， 就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的 索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt; A maven project to study maven. &lt;/description&gt; &lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven&gt;&lt;/maven&gt; &lt;/prerequisites&gt; &lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!-- 问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!-- 该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.baidu.com/banseon &lt;/url&gt; &lt;/issueManagement&gt; &lt;!-- 项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!-- 持续集成系统的名字，例如continuum --&gt; &lt;system&gt;&lt;/system&gt; &lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!-- 传送通知的途径 --&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 发生错误时是否通知 --&gt; &lt;sendOnError&gt;&lt;/sendOnError&gt; &lt;!-- 构建失败时是否通知 --&gt; &lt;sendOnFailure&gt;&lt;/sendOnFailure&gt; &lt;!-- 构建成功时是否通知 --&gt; &lt;sendOnSuccess&gt;&lt;/sendOnSuccess&gt; &lt;!-- 发生警告时是否通知 --&gt; &lt;sendOnWarning&gt;&lt;/sendOnWarning&gt; &lt;!-- 不赞成使用。通知发送到哪里 --&gt; &lt;address&gt;&lt;/address&gt; &lt;!-- 扩展配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!-- 项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!-- 邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; banseon@126.com &lt;/post&gt; &lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; banseon@126.com &lt;/subscribe&gt; &lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; banseon@126.com &lt;/unsubscribe&gt; &lt;!-- 你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.baidu.com/banseon/demo/dev/ &lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!-- 项目开发者列表 --&gt; &lt;developers&gt; &lt;!-- 某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!-- SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!-- 项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!-- 项目开发者的email --&gt; &lt;email&gt; banseon@126.com &lt;/email&gt; &lt;!-- 项目开发者的主页的URL --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目开发者所属组织 --&gt; &lt;organization&gt; demo &lt;/organization&gt; &lt;!-- 项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt; http://hi.baidu.com/xxx &lt;/organizationUrl&gt; &lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5 &lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!-- 项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;!-- 项目贡献者的全名 --&gt; &lt;name&gt;&lt;/name&gt; &lt;!-- 项目贡献者的email --&gt; &lt;email&gt;&lt;/email&gt; &lt;!-- 项目贡献者的主页的URL --&gt; &lt;url&gt;&lt;/url&gt; &lt;!-- 项目贡献者所属组织 --&gt; &lt;organization&gt;&lt;/organization&gt; &lt;!-- 项目贡献者所属组织的URL --&gt; &lt;organizationUrl&gt;&lt;/organizationUrl&gt; &lt;!-- 项目贡献者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目贡献者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;&lt;/timezone&gt; &lt;!-- 项目贡献者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!-- 该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。 如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!-- license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!-- 官方的license正文页面的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon/LICENSE-2.0.txt &lt;/url&gt; &lt;!-- 项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo &lt;/distribution&gt; &lt;!-- 关于license的补充信息 --&gt; &lt;comments&gt; A business-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag&gt;&lt;/tag&gt; &lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon &lt;/url&gt; &lt;/scm&gt; &lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!-- 组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!-- 组织主页的URL --&gt; &lt;url&gt; http://www.baidu.com/banseon &lt;/url&gt; &lt;/organization&gt; &lt;!-- 构建项目需要的信息 --&gt; &lt;build&gt; &lt;!-- 该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对 于pom.xml的相对路径。 --&gt; &lt;sourceDirectory&gt;&lt;/sourceDirectory&gt; &lt;!-- 该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容会 被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory&gt;&lt;/scriptSourceDirectory&gt; &lt;!-- 该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。 该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory&gt;&lt;/testSourceDirectory&gt; &lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;!-- 被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory&gt;&lt;/testOutputDirectory&gt; &lt;!-- 使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!-- 描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!-- 构建扩展的groupId --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 构建扩展的artifactId --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 构建扩展的版本 --&gt; &lt;version&gt;&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!-- 当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal&gt;&lt;/defaultGoal&gt; &lt;!-- 这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在 最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!-- 这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为 org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素 里列出。 --&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 包含的模式列表，例如**/*.xml. --&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;!-- 排除的模式列表，例如**/*.xml --&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!-- 这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;!-- 描述了测试相关的资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为 org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素 里列出。 --&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;!-- 描述存放测试相关的资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 包含的模式列表，例如**/*.xml. --&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;!-- 排除的模式列表，例如**/*.xml --&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 构建产生的所有文件存放的目录 --&gt; &lt;directory&gt;&lt;/directory&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName&gt;&lt;/finalName&gt; &lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters&gt;&lt;/filters&gt; &lt;!-- 子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本 地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!-- 使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!-- 插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该 元素才被设置成enabled。 --&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!-- execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;&lt;/phase&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals&gt;&lt;/goals&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 该项目使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!-- 插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该 元素才被设置成enabled。 --&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!-- execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;&lt;/phase&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals&gt;&lt;/goals&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 作为DOM对象的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!-- 构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它能够 在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元 素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!-- profile默认是否激活的标志 --&gt; &lt;activeByDefault&gt;true/false&lt;/activeByDefault&gt; &lt;!-- 当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本 不是以1.4开头的JDK。 --&gt; &lt;jdk&gt;jdk版本，如:1.7&lt;/jdk&gt; &lt;!-- 当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!-- 激活profile的操作系统的名字 --&gt; &lt;name&gt; Windows XP &lt;/name&gt; &lt;!-- 激活profile的操作系统所属家族(如 &apos;windows&apos;) --&gt; &lt;family&gt; Windows &lt;/family&gt; &lt;!-- 激活profile的操作系统体系结构 --&gt; &lt;arch&gt; x86 &lt;/arch&gt; &lt;!-- 激活profile的操作系统版本 --&gt; &lt;version&gt; 5.1.2600 &lt;/version&gt; &lt;/os&gt; &lt;!-- 如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile 就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹 配属性值字段 --&gt; &lt;property&gt; &lt;!-- 激活profile的属性的名称 --&gt; &lt;name&gt; mavenVersion &lt;/name&gt; &lt;!-- 激活profile的属性的值 --&gt; &lt;value&gt; 2.0.3 &lt;/value&gt; &lt;/property&gt; &lt;!-- 提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!-- 如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!-- 如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt; /usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!-- 构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;directory&gt;&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath&gt;&lt;/targetPath&gt; &lt;filtering&gt;&lt;/filtering&gt; &lt;directory&gt;&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;&lt;/exclude&gt; &lt;/excludes&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory&gt;&lt;/directory&gt; &lt;finalName&gt;&lt;/finalName&gt; &lt;filters&gt;&lt;/filters&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;&lt;/id&gt; &lt;phase&gt;&lt;/phase&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!-- 参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;extensions&gt;true/false&lt;/extensions&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;&lt;/id&gt; &lt;phase&gt;&lt;/phase&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals&gt;&lt;/goals&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的 相对路径 --&gt; &lt;modules&gt; &lt;!--子项目相对路径--&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;id&gt;&lt;/id&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;&lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的 仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!-- 该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看 到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt;&lt;/reporting&gt; &lt;!-- 参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; &lt;/distributionManagement&gt; &lt;!-- 参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules&gt; &lt;!--子项目相对路径--&gt; &lt;module&gt;&lt;/module&gt; &lt;/modules&gt; &lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直）， daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中， 为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled&gt;&lt;enabled&gt; &lt;updatePolicy&gt;&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; banseon-repository-proxy &lt;/id&gt; &lt;!-- 远程仓库名称 --&gt; &lt;name&gt; banseon-repository-proxy &lt;/name&gt; &lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认 的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default &lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。 要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 依赖的group ID --&gt; &lt;groupId&gt; org.apache.maven &lt;/groupId&gt; &lt;!-- 依赖的artifact ID --&gt; &lt;artifactId&gt; maven-artifact &lt;/artifactId&gt; &lt;!-- 依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt; 3.8.1 &lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展 名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt; jar &lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如， 如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生 成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!-- 依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt; test &lt;/scope&gt; &lt;!-- 仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件 系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!-- 当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的 依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt; spring-core &lt;/artifactId&gt; &lt;groupId&gt; org.springframework &lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!-- 可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。 可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt; true &lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!-- 该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!-- true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!-- 所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!-- 使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!-- plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!-- 报表插件在仓库里的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 报表插件在仓库里的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 被使用的报表插件的版本（或版本范围） --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 报表插件的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如， 有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报 表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id&gt;&lt;/id&gt; &lt;!-- 产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;!-- 配置是否被继承到子POMs --&gt; &lt;inherited&gt;true/false&lt;/inherited&gt; &lt;!-- 这个集合里使用到哪些报表 --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖 （必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过 group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 参见dependencies/dependency元素 --&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者 把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见 repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; banseon maven2 &lt;/name&gt; &lt;url&gt; file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/repository&gt; &lt;!-- 构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见 distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt; banseon-maven2 &lt;/id&gt; &lt;name&gt; Banseon-maven2 Snapshot Repository &lt;/name&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/usr/local/maven-snapshot &lt;/url&gt; &lt;layout&gt;&lt;/layout&gt; &lt;/snapshotRepository&gt; &lt;!-- 部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; banseon-site &lt;/id&gt; &lt;!-- 部署位置的名称 --&gt; &lt;name&gt; business api website &lt;/name&gt; &lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位 那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!-- 构件新的group ID --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;!-- 构件新的artifact ID --&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;!-- 构件新的版本号 --&gt; &lt;version&gt;&lt;/version&gt; &lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message&gt;&lt;/message&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值 有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status&gt;&lt;/status&gt; &lt;/distributionManagement&gt; &lt;!-- 以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里 activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties&gt; &lt;name&gt;value&lt;/name&gt; &lt;/properties&gt; &lt;/project&gt;]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从-Eclipse或NetBeans-转换到-IntelliJ-IDEA]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E4%BB%8E-Eclipse%E6%88%96NetBeans-%E8%BD%AC%E6%8D%A2%E5%88%B0-IntelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[https://www.jetbrains.com/help/idea/2017.1/eclipse.html eclipsehttps://www.jetbrains.com/help/idea/2017.1/netbeans.html netbeans]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+oschina搭建个人博客]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E4%BD%BF%E7%94%A8hexo%2Boschina%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[http://lanmiao.oschina.io/2017/01/01/hexo1/]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数式编程初探]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[http://www.ruanyifeng.com/blog/2012/04/functional_programming.html]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[去除百度置顶的广告，优化百度搜索]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E5%8E%BB%E9%99%A4%E7%99%BE%E5%BA%A6%E7%BD%AE%E9%A1%B6%E7%9A%84%E5%B9%BF%E5%91%8A%EF%BC%8C%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[人人都唾弃百度的竞价排名，搜个关键词，前两页全tm广告，每每看到这个就恶心了。解决办法：安装浏览器插件，去掉置顶的广告。优化搜索。正常来说三个插件就够了。1.去除百度搜索置顶推广2.百度搜索-优化3.网友预加载（自动加载下一页等神奇功能）然而，我一般是装这么多软件，然后系统根据当前网站自动调用可用的软件。 我装的软件如下 然后访问百度时这些插件启动，13个： 安装过程：Tampermonkey 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。 虽然有些受支持的浏览器拥有原生的用户脚本支持，但 Tampermonkey 将在您的用户脚本管理方面提供更多的便利。 它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能， 同时Tampermonkey还有可能正常运行原本并不兼容的脚本。 应用市场，搜索Tampermonkey，安装即可。中文叫油猴子。安装完后，获取脚本的网站：https://greasyfork.org/zh-CN 步骤如下：第一步：安装一个用户脚本管理器 Chrome 上的 Tampermonkey 要使用用户脚本，您首先需要安装一个用户脚本管理器。根据您使用的浏览器不同，可用的用户脚本管理器也有所不同。Chrome：Tampermonkey 或 Violent monkeyFirefox：Greasemonkey、Tampermonkey或 ViolentmonkeySafari：TampermonkeyMicrosoft Edge：TampermonkeyOpera：Tampermonkey或 ViolentmonkeyMaxthon：ViolentmonkeyDolphin：TampermonkeyUC：TampermonkeyQupzilla：（不需要额外软件） 第二步：安装一个用户脚本用户脚本的安装按钮 浏览此网站 查找您想尝试的用户脚本。最流行的用户脚本有：百度广告(首尾推广及右侧广告)清理 - 彻底清理百度搜索(www.baidu.com)结果首尾的推广广告、二次顽固广告与右侧广告，并防止反复跳过网站等待、验证码及登录 - 移除各类网站验证码、登录、倒计时及更多!网盘自动填写密码【增强版】 - 网盘自动填写提取密码【增强版】+网盘超链接与提取码融合。百度云插件+APIKey - 在百度云网盘的页面添加一个搜索框，调用搜索API搜索所有公开分享文件// To add a search frame that calls some api for searching some public shared files in BaiduYun cloud netdisk.网页限制解除 - 通杀大部分网站，可以解除禁止复制、剪切、选择文本、右键菜单的限制。 在您找到想要的用户脚本后，点击用户脚本页面上绿色的安装按钮，您的用户脚本管理器将询问您是否安装。 第三步：使用用户脚本转至用户脚本适用的网站。它应该已自动启动和生效。在试用用户脚本后，您可以返回用户脚本页面，给用户脚本的作者留下反馈。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在windows中安装ubuntu]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E5%9C%A8windows%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/freeboy1015/article/details/9319673]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用Intellij调试AngularJS]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Intellij%E8%B0%83%E8%AF%95AngularJS%2F</url>
    <content type="text"><![CDATA[设置Intellij或Webstorm来调试AngularJS很简单。 1.为Chrome安装JetBrains IDE支持扩展转到Chrome网上应用店，并添加到 chromeBrains IDE支持 2.在Intellij上创建一个新的JavaScript调试配置在Intellij上，转到“运行&gt;编辑配置…”，或单击菜单上的“编辑配置…”按钮： 然后添加一个新的JavaScript调试配置。 3.配置您的JavaScript调试配置一旦你创建了一个新的JavaScript配置，你需要设置它： 名称：添加名称以标识您的配置。 网址：您需要在此处放置运行应用的网址。AngularJS和Jhipster都带有一个Grunt任务，在9000端口启动一个Web服务器，所以我的URL是“http：// localhost：9000 /”。 浏览器：我只使用Chrome浏览器，但应该可以使用任何其他浏览器。 本地文件的远程URL：您需要将本地文件与您的远程应用程序相链接。在项目中找到您的index.html文件，并设置远程URL。在我的情况下，远程URL是http：// localhost：9000 / index.html。 4.调试JavaScript调试配置最后，您只需要点击“Debug”，你就可以调试你的应用程序了。如果一切正常，将打开一个新窗口，并附上以下注释“JetBrains IDE Support”正在调试此选项卡。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java-8-Lambda表达式（Oracle官方文档版）]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java-8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Oracle%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java 8 问世三年了，9马上也要问世了，所以，嗯，我要开始学8了…… 官方文档：http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html 为什么用Lambda表达式只是代码简洁了这个好处的话，并不能打动很多观众，java 8也不会这么令人期待，其实java 8引入lambda迫切需求是因为lambda 表达式能简化集合上数据的多线程或者多核的处理，提供更快的集合处理速度 匿名类的问题是，如果您的匿名类的实现非常简单，例如仅包含一个方法的接口，则匿名类的语法可能看起来很笨重且不清楚。在这些情况下，您通常会尝试将功能作为参数传递给另一种方法，例如当有人点击按钮时应该采取什么措施。Lambda表达式使您能够执行此操作，将功能视为方法参数或代码作为数据。 文章概览 Lambda表达式的理想用例 方法1：创建搜索匹配一个特征的成员的方法 方法2：创建更广泛的搜索方法 方法3：在本地类中指定搜索条件代码 方法4：在匿名类中指定搜索条件代码 方法5：使用Lambda表达式指定搜索条件代码 方法6：使用带有Lambda表达式的标准功能接口 方法7：在整个应用程序中使用Lambda表达式 方法8：更广泛地使用泛型 方法9：使用接受Lambda表达式作为参数的聚合操作 GUI应用程序中的Lambda表达式 Lambda表达式的语法 访问封闭范围的局部变量 目标打字 目标类型和方法参数 序列化 Lambda表达式的理想用例假设您正在创建一个社交网络应用程序。您想要创建一个功能，使管理员可以在符合特定条件的社交网络应用程序的成员上执行任何类型的操作（例如发送消息）。下表详细描述了这种用例：假设这个社交网络应用程序的成员由以下Person类别表示 ：12345678910111213141516171819public class Person &#123; public enum Sex &#123; MALE, FEMALE &#125; String name; LocalDate birthday; Sex gender; String emailAddress; public int getAge() &#123; // ... &#125; public void printPerson() &#123; // ... &#125;&#125; 假设您的社交网络应用程序的成员存储在一个List实例中。本节首先介绍了这种用例的天真的方法。它使用本地和匿名类改进了这种方法，然后使用lambda表达式使用高效简明的方法来完成。方法1：创建搜索匹配一个特征的成员的方法 一种简单的方法是创建几种方法; 每个方法搜索符合一个特征的成员，如性别或年龄。以下方法打印比指定年龄更早的成员：1234567public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) &#123; for (Person p : roster) &#123; if (p.getAge() &gt;= age) &#123; p.printPerson(); &#125; &#125;&#125; 注意：A 集合是一个对象，该组中的多个元素到单个单元中。集合用于存储，检索，操纵和传达聚合数据。 这种方法可能会使您的应用程序变得脆弱，这是因为引入更新（例如较新的数据类型）而导致应用程序无法正常工作的可能性。假设您升级应用程序并更改Person类的结构，使其包含不同的成员变量; 可能是使用不同数据类型或算法的类记录和测量年龄。您将不得不重写很多API以适应这种变化。此外，这种方法是不必要的限制; 例如，如果你想打印比一定年龄小的成员怎么办？ 方法2：创建更广泛的搜索方法以下方法比通用更为普遍printPersonsOlderThan; 会在特定范围内打印成员：12345678public static void printPersonsWithinAgeRange( List&lt;Person&gt; roster, int low, int high) &#123; for (Person p : roster) &#123; if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123; p.printPerson(); &#125; &#125;&#125; 如果要打印指定性别的成员或指定的性别和年龄范围的组合，该怎么办？如果您决定更改Person课程并添加其他属性（如关系状态或地理位置），该怎么办？虽然这种方法比一般的方法更多printPersonsOlderThan，但是为每个可能的搜索查询创建一个单独的方法仍然可能导致脆弱的代码。您可以将指定要在其他类中搜索的条件的代码分开。方法3：在本地类中指定搜索条件代码以下方法打印与您指定的搜索条件匹配的成员：12345678public static void printPersons( List&lt;Person&gt; roster, CheckPerson tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 该方法通过调用该方法来检查参数中Person包含的每个实例是否满足参数中指定的搜索条件。如果方法返回一个值，那么该方法在实例上被调用。ListrosterCheckPersontestertester.testtester.testtrueprintPersonsPerson要指定搜索条件，您可以实现该 CheckPerson接口：123interface CheckPerson &#123; boolean test(Person p);&#125; 以下类CheckPerson通过指定方法的实现来实现接口test。该方法可以筛选符合美国Selective Service的成员：true如果Person参数为男性且年龄在18至25之间，则返回值：1234567class CheckPersonEligibleForSelectiveService implements CheckPerson &#123; public boolean test(Person p) &#123; return p.gender == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; &#125;&#125; 要使用此类，您将创建一个新的实例并调用printPersons方法：1printPersons( roster, new CheckPersonEligibleForSelectiveService()); 虽然这种方法不那么脆弱 - 如果您更改了结构，您不必重写方法Person- 您仍然有其他代码：您计划在应用程序中执行的每个搜索的新界面和本地类。因为CheckPersonEligibleForSelectiveService 实现一个接口，你可以使用一个匿名类而不是一个本地类，并绕过需要为每个搜索声明一个新的类。方法4：在匿名类中指定搜索条件代码以下调用该方法printPersons的一个参数是一个匿名类，用于过滤在美国有资格选择性服务的成员：男性，年龄在18至25岁之间的成员：12345678910printPersons( roster, new CheckPerson() &#123; public boolean test(Person p) &#123; return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; &#125; &#125;); 这种方法减少了所需的代码量，因为您不必为每个要执行的搜索创建一个新类。然而，匿名类的语法是庞大的，因为CheckPerson接口只包含一种方法。在这种情况下，您可以使用lambda表达式而不是匿名类，如下一节所述。方法5：使用Lambda表达式指定搜索条件代码该CheckPerson接口是一个功能接口。功能界面是只包含一个抽象方法的任何接口 。功能界面可能包含一个或多个 默认方法静态方法由于功能界面只包含一个抽象方法，因此在实现时可以省略该方法的名称。为此，您不必使用匿名类表达式，而是使用lambda表达式，该表达式在以下方法调用中突出显示：1234567printPersons( roster, (Person p) -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25);` 有关如何定义lambda表达式的信息，请参阅Lambda表达式的语法。您可以使用标准功能界面来代替接口CheckPerson，这进一步减少了所需的代码量。 方法6：使用带有Lambda表达式的标准功能接口12345Reconsider the CheckPerson interface:interface CheckPerson &#123; boolean test(Person p);&#125; 这是一个非常简单的界面。它是一个功能界面，因为它只包含一个抽象方法。该方法需要一个参数并返回一个 boolean值。该方法非常简单，可能不值得在应用程序中定义一个。因此，JDK定义了几个标准的功能接口，您可以在包中找到它们java.util.function。例如，您可以使用该 Predicate 界面代替CheckPerson。该界面包含以下方法boolean test(T t)：1234interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 该接口Predicate是通用接口的示例。通用类型（如通用接口）在尖括号（&lt;&gt;）中指定一个或多个类型参数。此接口只包含一个类型参数T。当您使用实际类型参数声明或实例化通用类型时，您将具有参数化类型。例如，参数化类型Predicate如下：123interface Predicate&lt;Person&gt; &#123; boolean test(Person t);&#125; 此参数化类型包含一个具有相同返回类型和参数的方法CheckPerson.boolean test(Person p)。因此，您可以使用以下方法Predicate来代替CheckPerson：12345678public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 因此，以下方法调用与printPersons在方法3中调用时相同 ：在本地类中指定搜索条件代码以获取符合选择性服务的成员：123456printPersonsWithPredicate( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25); 这不是使用lambda表达式的唯一可能的方法。以下方法建议使用lambda表达式的其他方法。方法7：在整个应用程序中使用Lambda表达式重新考虑printPersonsWithPredicate 使用lambda表达式的方法：12345678public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; p.printPerson(); &#125; &#125;&#125; 该方法检查参数中Person包含的每个实例是否满足参数中指定的条件。如果实例满足由此指定的条件，则该实例将调用该方法。ListrosterPredicatetesterPersontesterprintPersronPerson 而不是调用该方法printPerson，您可以指定在Person满足指定条件的那些实例上执行的其他操作tester。您可以使用lambda表达式指定此操作。假设你想要一个类似于一个lambda表达式printPerson，一个参数（一个类型的对象Person）并返回void。记住，要使用lambda表达式，您需要实现一个功能界面。在这种情况下，您需要一个包含抽象方法的功能界面，该方法可以使用一个类型的参数Person并返回void。该 Consumer 界面包含void accept(T t)具有这些特征的方法 。以下方法将p.printPerson()使用Consumer调用该方法的实例替换该调用 accept：12345678910public static void processPersons( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Consumer&lt;Person&gt; block) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; block.accept(p); &#125; &#125;&#125; 因此，以下方法调用与printPersons在方法3中调用的方法相同：在本地类中指定搜索条件代码以获取符合选择性服务的成员。用于打印成员的lambda表达式突出显示：1234567processPersons( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.printPerson()); 如果您想要更多地使用会员的个人资料，而不是打印出来。假设您要验证会员的个人资料或检索他们的联系信息？在这种情况下，您需要一个功能界面，其中包含一个返回值的抽象方法。该 Function 接口包含的方法R apply(T t)。以下方法检索由参数指定的数据mapper，然后对该参数指定的操作执行操作block：123456789101112public static void processPersonsWithFunction( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Function&lt;Person, String&gt; mapper, Consumer&lt;String&gt; block) &#123; for (Person p : roster) &#123; if (tester.test(p)) &#123; String data = mapper.apply(p); block.accept(data); &#125; &#125;&#125; 以下方法从包含在roster哪些符合选择性服务的每个成员中检索电子邮件地址，然后打印：12345678processPersonsWithFunction( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email)); 方法8：更广泛地使用泛型 重新考虑该方法processPersonsWithFunction。以下是它的一般版本，它接受包含任何数据类型元素的集合作为参数：123456789101112public static &lt;X, Y&gt; void processElements( Iterable&lt;X&gt; source, Predicate&lt;X&gt; tester, Function &lt;X, Y&gt; mapper, Consumer&lt;Y&gt; block) &#123; for (X p : source) &#123; if (tester.test(p)) &#123; Y data = mapper.apply(p); block.accept(data); &#125; &#125;&#125; 要打印符合选择性服务的会员的电子邮件地址，请调用以下processElements方法：12345678processElements( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email)); 此方法调用执行以下操作： 1.从集合中获取对象的源source。在此示例中，它Person从集合中获取对象的源roster。请注意，作为roster类型集合的集合也是类型List的对象Iterable。 过滤与该Predicate对象匹配的对象tester。在此示例中，该Predicate对象是一个lambda表达式，用于指定哪些成员将具有选择性服务的资格。 3.映射由指定的每个经滤波的对象的值Function的对象mapper。在此示例中，该Function对象是一个返回成员的电子邮件地址的lambda表达式。 4.由指定执行每个映射对象的动作Consumer对象block。在这个例子中，该Consumer对象是一个lambda表达式，它打印一个字符串，它是Function对象返回的电子邮件地址。您可以使用聚合操作替换这些操作。 方法9：使用接受Lambda表达式作为参数的聚合操作123456789roster .stream() .filter( p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25) .map(p -&gt; p.getEmailAddress()) .forEach(email -&gt; System.out.println(email));` 下表列出了方法processElements执行的每个操作与相应的聚合操作： 操作filter，map并且forEach是聚合操作。从流中聚合操作流程元素，而不是直接从集合（这是在这个示例中调用的第一个方法的原因stream）。甲流是元素的序列。与集合不同，它不是存储元素的数据结构。相反，流携带来自源的值，例如通过管道的收集。甲管道是流的操作的序列，其在该示例中是filter- - 。map forEach另外，聚合操作通常接受lambda表达式作为参数，使您可以自定义它们的行为。 GUI应用程序中的Lambda表达式要在图形用户界面（GUI）应用程序（如键盘操作，鼠标操作和滚动操作）中处理事件，您通常会创建事件处理程序，通常涉及实现特定接口。事件处理接口通常是功能接口; 他们往往只有一种方法。1234567btn.setOnAction（new EventHandler &lt;ActionEvent&gt;（）&#123; @Override public void handle（ActionEvent event）&#123; System.out.println（“Hello World！”）; &#125; &#125;）; 方法调用btn.setOnAction指定当您选择由btn对象表示的按钮时会发生什么。此方法需要一个类型的对象EventHandler。该EventHandler 界面只包含一种方法void handle(T event)。此接口是一个功能界面，因此您可以使用以下突出显示的lambda表达式来替换它：123btn.setOnAction（ event - &gt; System.out.println（“Hello World！”） ）; Lambda表达式的语法 用括号括起来的逗号分隔的形式参数列表。该CheckPerson.test方法包含一个参数， p它表示Person该类的一个实例 。 注意：您可以忽略lambda表达式中参数的数据类型。另外，如果只有一个参数，可以省略括号。例如，以下lambda表达式也是有效的：123p - &gt; p.getGender（）== Person.Sex.MALE &amp;&amp; p.getAge（）&gt; = 18 &amp;&amp; p.getAge（）&lt;= 25 箭头令牌， -&gt; 一个由单个表达式或语句块组成的主体。此示例使用以下表达式： 123p.getGender（）== Person.Sex.MALE &amp;&amp; p.getAge（）&gt; = 18 &amp;&amp; p.getAge（）&lt;= 25 如果指定单个表达式，则Java运行时将评估表达式，然后返回其值。或者，您可以使用return语句：12345p -&gt; &#123; return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25;&#125; return语句不是表达式; 在lambda表达式中，您必须用大括号（{}）括起来。但是，您不必在大括号中包含一个void方法调用。例如，以下是有效的lambda表达式：1email -&gt; System.out.println(email) 请注意，lambda表达式看起来很像一个方法声明; 您可以将lambda表达式视为匿名方法 - 没有名称的方法。 以下示例 Calculator是使用多个形式参数的lambda表达式的示例：123456789101112131415161718192021public class Calculator &#123; interface IntegerMath &#123; int operation(int a, int b); &#125; public int operateBinary(int a, int b, IntegerMath op) &#123; return op.operation(a, b); &#125; public static void main(String... args) &#123; Calculator myApp = new Calculator(); IntegerMath addition = (a, b) -&gt; a + b; IntegerMath subtraction = (a, b) -&gt; a - b; System.out.println(&quot;40 + 2 = &quot; + myApp.operateBinary(40, 2, addition)); System.out.println(&quot;20 - 10 = &quot; + myApp.operateBinary(20, 10, subtraction)); &#125;&#125; 该方法operateBinary对两个整数操作数进行数学运算。操作本身由一个实例指定IntegerMath。的例子中定义了lambda表达式两个操作，addition和subtraction。该示例打印以下内容： 40 + 2 = 4220 - 10 = 10 访问封闭范围的局部变量 像本地和匿名类一样，lambda表达式可以 捕获变量 ; 它们对包围范围的局部变量具有相同的访问权限。但是，与本地和匿名类不同，lambda表达式没有任何阴影问题（有关详细信息，请参阅 阴影）。Lambda表达式是词法的范围。这意味着它们不会从超类型继承任何名称或引入新的范围界定。lambda表达式中的声明就像在封闭环境中一样被解释。以下示例 LambdaScopeTest演示如下：123456789101112131415161718192021222324252627282930313233343536373839import java.util.function.Consumer;public class LambdaScopeTest &#123; public int x = 0; class FirstLevel &#123; public int x = 1; void methodInFirstLevel(int x) &#123; // The following statement causes the compiler to generate // the error &quot;local variables referenced from a lambda expression // must be final or effectively final&quot; in statement A: // // x = 99; Consumer&lt;Integer&gt; myConsumer = (y) -&gt; &#123; System.out.println(&quot;x = &quot; + x); // Statement A System.out.println(&quot;y = &quot; + y); System.out.println(&quot;this.x = &quot; + this.x); System.out.println(&quot;LambdaScopeTest.this.x = &quot; + LambdaScopeTest.this.x); &#125;; myConsumer.accept(x); &#125; &#125; public static void main(String... args) &#123; LambdaScopeTest st = new LambdaScopeTest(); LambdaScopeTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); &#125;&#125; T此示例生成以下输出： x = 23y = 23this.x = 1LambdaScopeTest.this.x = 0 如果在lambda表达式的声明中替换参数x，编译器将生成一个错误：ymyConsumer1234Consumer&lt;Integer&gt; myConsumer = (x) -&gt; &#123; // ...&#125;` 编译器生成错误“变量x已经在方法methodInFirstLevel（int）中定义”，因为lambda表达式不会引入新的一级范围。因此，您可以直接访问封闭范围的字段，方法和局部变量。例如，lambda表达式直接访问x该方法的参数methodInFirstLevel。要访问包围类中的变量，请使用关键字this。在这个例子中，this.x指的是成员变量FirstLevel.x。 然而，像本地和匿名类一样，lambda表达式只能访问最终或有效最终的封闭块的局部变量和参数。例如，假设您在methodInFirstLevel定义语句之后立即添加以下赋值语句：1234void methodInFirstLevel(int x) &#123; x = 99; // ...&#125; 由于这个赋值语句，变量FirstLevel.x不再是有效的最终了。因此，Java编译器会生成类似于“lambda表达式引用的本地变量必须是final”或“final”的错误消息，其中lambda表达式myConsumer尝试访问该FirstLevel.x变量： 1System.out.println（“x =”+ x）; 目标打字你如何确定一个lambda表达式的类型？回想一下选择的男性和18至25岁之间的成员的lambda表达：123p - &gt; p.getGender（）== Person.Sex.MALE&amp;&amp; p.getAge（）&gt; = 18&amp;&amp; p.getAge（）&lt;= 25 public static void printPersons(List roster, CheckPerson tester)在方法3：在局部类指定搜索条件码 public void printPersonsWithPredicate(List roster, Predicate tester)在方法6：Lambda表达式使用标准的功能接口当Java运行时调用该方法时 printPersons，它期望数据类型CheckPerson，因此lambda表达式是这种类型的。但是，当Java运行时调用该方法时printPersonsWithPredicate，它期待数据类型Predicate，因此lambda表达式是这种类型的。这些方法期望的数据类型称为目标类型。要确定lambda表达式的类型，Java编译器将使用上下文的目标类型或其中找到lambda表达式的情境。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式： 变量声明分配回报表阵列初始化器方法或构造函数参数Lambda表达体条件表达式， ?:演员表达式目标类型和方法参数 对于方法参数，Java编译器使用其他两种语言功能来确定目标类型：重载解析和类型参数推断。 考虑以下两个功能界面（ java.lang.Runnable和 java.util.concurrent.Callable）：1234567public interface Runnable &#123; void run();&#125;public interface Callable&lt;V&gt; &#123; V call();&#125; 该方法Runnable.run不返回值，而是Callable.call。假设您已经invoke按照以下方法重载了该方法1234567void invoke(Runnable r) &#123; r.run();&#125;&lt;T&gt; T invoke(Callable&lt;T&gt; c) &#123; return c.call();&#125; 在以下语句中将调用哪种方法？ String s = invoke（（） - &gt;“done”）; 该方法invoke(Callable)将被调用，因为该方法返回一个值; 该方法 invoke(Runnable)没有。在这种情况下，lambda表达式的类型() -&gt; “done”是Callable。 序列化如果lambda表达式的目标类型及其捕获的参数是可序列化的，则可以 序列化它。然而，像 内部类一样，强烈地不鼓励lambda表达式的序列化。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站升级为https过程记录-tomcat]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7%E4%B8%BAhttps%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95-tomcat%2F</url>
    <content type="text"><![CDATA[1.创建.keystore12345678910111213141516171819202122[root@centos apache-tomcat-6.0.37]# keytool -genkey -alias tomcat -keyalg RSA -keystore /root/tomcat/apache-tomcat-6.0.37/conf/.keystore输入keystore密码： 再次输入新密码: 您的名字与姓氏是什么？ [Unknown]： free4lab您的组织单位名称是什么？ [Unknown]： free4lab您的组织名称是什么？ [Unknown]： free4lab您所在的城市或区域名称是什么？ [Unknown]： beijing您所在的州或省份名称是什么？ [Unknown]： beijing该单位的两字母国家代码是什么 [Unknown]： CNCN=free4lab, OU=free4lab, O=free4lab, L=beijing, ST=beijing, C=CN 正确吗？ [否]： y输入&lt;tomcat&gt;的主密码 （如果和 keystore 密码相同，按回车）： [root@centos apache-tomcat-6.0.37]# cat conf/.keystore` 2.然后修改tomcat配置文件server.xml123&lt;Connector port=&quot;8800&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot; clientAuth=&quot;false&quot; keystoreFile=&quot;/opt/tomcat/conf/.keystore&quot; keystorePass=&quot;wewell&quot; sslProtocol=&quot;TLS&quot; /&gt; 然后重启tomcat访问即可： 遇到的坑 hppt和https不能同时访问提供一个解决思路 1.相对协议如果你的网站同时准备了 https 资源和 http 资源，那么，可以使用相对协议可以帮助你实现当网站引入的都是 http 资源，网站域名更换为 https 后的无缝切换。具体使用方法为：1//![](//domain.com/img/logo.png) 简而言之，就是将URL的协议（http、https）去掉，只保留//及后面的内容。这样，在使用https的网站中，浏览器会通过https请求URL，否则就通过http发送请求。附注：如果是浏览本地文件，浏览器通过file://协议发送请求，导致请求失败，因此本地测试最好是搭建一个本地服务器。HTML5 Boilerplate 使用相对协议请求 Google CDN 中的 jQuery ，使用方式为：1234&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt;!window.jQuery &amp;&amp; document.write(unescape(&apos;%3Cscript src=&quot;js/libs/jquery-1.4.2.js&quot;%3E%3C/script%3E&apos;))&lt;/script&gt; 上面的例子中除了引用 Google CDN 中的文件外，还添加了一个本地 jQuery 链接，以便连接 Google CDN 失败后，使用本地副本。 代码判断过程为：首先检查 jquery 对象是否存在，如果存在，证明 Google CDN 运行正常；如果不存在，则说明连接 Google CDN 失败，引入本地 jQuery 库。 本猿认为，在国内相对特殊的网络环境中，Google CDN 请求缓慢甚至失败常有，因此不推荐引用 Google CDN 托管的各种库。即便有备用链接，浏览器还是会多次尝试请求 Google CDN 中的文件，这个过程可谓漫长，严重影响页面载入速度。 2.使用 iframe 使用 iframe 的方式引入 http 资源，比如在 https 里面播放优酷的视频，我们可以先在一个 http 的页面里播放优酷视频，然后将这个页面嵌入到 https 页面里就可以了。另外一个典型的例子是在 https 页面里通过 Ajax 的方式请求 http 资源，Chrome 是不允许直接 Ajax 请求 http 的。如果两个页面的内容都可以控制的话，当前窗口可以 iframe 窗口进行通信。 3.其他用法 这个小技巧同样适用于 CSS ：1.omg &#123; background: url(//websbestgifs.net/kittyonadolphin.gif); &#125; 附注：或@import引入样式表时使用相对协议，IE7、IE8 会下载文件两次。 我的angularjs程序解决思路所有的异步请求都是一个配置文件中定义的，我在程序开始运行时进行了判断，访问协议是http的就http访问，https的就https访问。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻墙]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E7%BF%BB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[fanqiang翻过帝国防护墙 赛风 windows版 Android版 iOS版 Firefly 萤火虫 windows osx Ubuntu 64位-Ubuntu 32位 Android 4.0.3 及以上-iOS 9.3 及以上 Tor Browser 的Meek模式https://www.torproject.org/download/download-easy.html.en 蓝灯https://github.com/getlantern/lantern/releases/tag/latest 浏览器插件 谷歌访问助手http://www.ggfwzs.com/ 仅仅供外贸和写代码等使用，勿违法乱纪]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决网络劫持]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E8%A7%A3%E5%86%B3%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[angularjs做的网站，用户反映路由跳转时总是回到首页。尼玛这个问题真恶心啊，远程调试半天，发现是他的网络被劫持了。然后自动给我把html也没换成了如下一个页面第一行代码就是跳转首页。cnm123&lt;script language=&quot;javascript&quot;&gt;setTimeout(&quot;location.replace(location.href.split(\&quot;#\&quot;)[0])&quot;,2000);&lt;/script&gt; 网上搜索都是一句话： 翻译过来就是：angularjs升级到1.6.3，cookie也升级到1.6.3， ui-router升级到0.4.2 。网上有人说原因是这个： 问题是怎么只劫持ui-view加载的模板，ng-include进来的模板就没有劫持。【对比ng-include的请求和ui-view的请求，发现Accept是不同的】ng-include的是：Accept:application/json, text/plain, /而ui-view 的是 Accept:text/html应该是这样的，劫持，基本劫持的是html页面，如果accept 为application/json，他的理解就是json而不是html， 而 accept为text/html时，自然就被劫持了。但只是知道了这个，仍然不知道怎么去改，因为这请求时ui-view里面封装的，不大好改。 然后终极办法是升级网站为https。好吧，那我就升级吧。 升级方法如下linux tomcat配置https12345678910111213141516171819202122[root@centos apache-tomcat-6.0.37]# keytool -genkey -alias tomcat -keyalg RSA -keystore /root/tomcat/apache-tomcat-6.0.37/conf/.keystore输入keystore密码： 再次输入新密码: 您的名字与姓氏是什么？ [Unknown]： free4lab您的组织单位名称是什么？ [Unknown]： free4lab您的组织名称是什么？ [Unknown]： free4lab您所在的城市或区域名称是什么？ [Unknown]： beijing您所在的州或省份名称是什么？ [Unknown]： beijing该单位的两字母国家代码是什么 [Unknown]： CNCN=free4lab, OU=free4lab, O=free4lab, L=beijing, ST=beijing, C=CN 正确吗？ [否]： y输入&lt;tomcat&gt;的主密码 （如果和 keystore 密码相同，按回车）： [root@centos apache-tomcat-6.0.37]# cat conf/.keystore 12345然后修改tomcat配置文件server.xml&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; keystoreFile=&quot;/root/tomcat/apache-tomcat-6.0.37/conf/.keystore&quot; keystorePass=&quot;yourpassword&quot; sslProtocol=&quot;TLS&quot; /&gt; 访问效果如下：通过curl访问，就忽略验证证书这一步12[root@f0 huahui]# curl --insecure https://192.168.1.190:8443/hello huahuiyangssl https` 这样浏览器访问就相对安全了，浏览器和服务端进行了非对称加密的握手，然后协商对称加密的密钥，然后进行相对快速的对称加密传输。即时密文在网络传输中被截获，因为无法获知对称密钥，所以这个http api就是安全的！]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超链接-a-中的文字自动换行]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E8%B6%85%E9%93%BE%E6%8E%A5-a-%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[css3：word-wrap:break-word 语法word-wrap: normal|break-word;值 描述normal 只在允许的断字点换行（浏览器保持默认处理）。break-word 在长单词或 URL 地址内部进行换行。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[越来越多的web服务开始采用RESTful风格设计和实现.html]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E4%B8%80%E6%9E%9A%E7%A8%8B%E5%BA%8F%E5%91%98%2F%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%A7%8B%E9%87%87%E7%94%A8RESTful%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[越来越多的web服务开始采用RESTful风格设计和实现 body { margin: 0; font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif; font-size: 14px; line-height: 20px; color: #777; background-color: white; } .container { width: 700px; margin-right: auto; margin-left: auto; } .post { font-family: Georgia, "Times New Roman", Times, "SimSun", serif; position: relative; padding: 70px; bottom: 0; overflow-y: auto; font-size: 16px; font-weight: normal; line-height: 25px; color: #515151; } .post h1{ font-size: 50px; font-weight: 500; line-height: 60px; margin-bottom: 40px; color: inherit; } .post p { margin: 0 0 35px 0; } .post img { border: 1px solid #D9D9D9; } .post a { color: #28A1C5; } 越来越多的web服务开始采用RESTful风格设计和实现 文章概要：什么是RESTful？RESTful的规范是什么？实际开发中RESTful是怎么使用的？RESTful架构，是目前最流行的一种互联网软件架构，因为其结构清晰，符合标准，易于理解，扩展方便，所以越来越多的网站采用RESTful架构设计了。 其实，RESTful是一种开发理念，是对http很好的诠释。维基百科说：REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准。维基百科称其为“具象状态传输”（英文：Representational State Transfer，简称REST），我理解为“表现层状态转化”，是Roy Thomas Fielding博士于2000年在他的博士论文 "Architectural Styles and the Design of Network-based Software Architectures" 中提出来的一种万维网软件架构风格。我们先来具体看下RESTful风格的url,比如我要查询商品信息， 那么非REST的url：http://.../queryGoods?id=1001&amp;type=t01 REST的url: http://.../goods/1001 可以看出REST特点：url简洁，将参数通过url传到服务器，而传统的url比较啰嗦，而且现实中浏览器地址栏会拼接一大串字符，相必你们都见过吧。但是采用REST的风格就会好很多，现在很多的网站已经采用这种风格了，这也是潮流方向，典型的就是url的短化转换。我认为理解RESTful的核心就是理解Representational State Transfer这三个单词的意思。具象的，就是指表现层，也就是“资源”，什么是资源呢？网站就是资源共享的东西，客户端（浏览器）访问web服务器，所获取的就叫资源。比如html，txt，json，图片，视频等等。浏览器通过URI确定一个资源，但是如何确定它的具体表现形式呢？应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。状态转换，就是客户端和服务器互动的一个工程，在这个过程中产生了数据的状态的变化叫做状态转换。客户端访问必然使用HTTP协议，HTTP协议实际上含有4个表示操作方式的动词，分别是 GET,POST,PUT,DELETE,他们分别对应四种操作。GET用于获取资源，POST用于新建或者更新资源，PUT用于更新资源，DElETE用于删除资源。GET和POST是表单提交的两种基本方式，比较常见，而PUT和DElETE不太常用。而且HTTP协议是一种无状态协议，这样就必须把所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生"状态转化"（State Transfer）综合上面的解释，RESTful架构就是：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML以及HTML这些现有的广泛流行的协议和标准，汲取了WWW的成功经验：无状态，以资源为中心，充分利用HTTP协议和URI协议，提供统一的接口定义，使得它作为一种设计Web服务的方法而变得流行。在某种意义上，通过强调URI和HTTP等早期Internet标准，REST是对大型应用程序服务器时代之前的Web方式的回归。目前Go对于REST的支持还是很简单的，通过实现自定义的路由规则，我们就可以为不同的method实现不同的handle，这样就实现了REST的架构。上边说的是标准，但是实际开发中并没有全部实现标准，因为那样会增加开发成本。增加代码复杂度。我们就ssm框架例举一下restful风格的开发方法。需求：RESTful方式实现商品信息查询，返回json数据1.添加DispatcherServlet的rest配置 2.URL 模板模式映射 @RequestMapping("/Items/{id}") public @ResponseBody Items(@PathVariable("id") String id,Model model) throws Exception{ //方法中使用@PathVariable获取id的值，使用model传回页面 //调用 service查询商品信息 ItemsCustom items = itemsService.findItemsById(id);return items; } 解释：@RequestMapping(value="/ Items/{id}")：{×××}占位符，请求的URL可以是“/Items/1”或“/Items/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。如果RequestMapping中表示为"/Items/{id}"，id和形参名称一致，@PathVariable不用指定名称。简单讲就是使用了两个注解@ResponseBody和@PathVariable，@ResponseBody指返回的数据，@PathVariable指传入的参数。@PathVariable将@RequestMapping("/Items/{id}")的占位符id的数据取出，放到形参中，处理完数据用@ResponseBody返回。其中spring框架都给我们定义好了，我们只需要明确指定传入参数是什么，返回值在这里我使用的是json，而指定方式就是两个注解。是不是很方便？这就大大简化了开发，提高了效率。本文章我首发在今日头条相关链接：Java开发的所有工具都在这里，全是最新版开发时，要选择Spring mvc ，还是选择Struts2作者：头条号 / 两毛五哥哥链接：http://toutiao.com/i6319842786224914945/来源：头条号（今日头条旗下创作平台）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>我是一枚程序员</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo+coding搭建博客]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2FHexo%2Bcoding%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[业界早有大佬说过，写博客大抵会经过三个阶段： 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 是时候表演真正的技术了。 建博客就是搭建了一个小型的网站，无非是编写html然后找一个免费的空间把html挂上去，给大家看。 但是，我希望我只专注于写文章，然后html自动生成，于是我就用了hexo这个工具，免费的空间，可以用大名鼎鼎的github，国内同类的开源中国旗下 码云，还有一个coding。由于我大天朝有防火墙，github网速不怎样，码云不支持绑定域名，所以我选择了coding，香港服务器，国内外速度都挺好。 介绍下怎么使用hexo吧。 学习基础： 前端开发基础：html,javascript,css,nodejs 建网站基础：购买域名，发布网站。 git使用基本技能。 makedown写作语法。 基本的命令行。 一、安装 nodejs官网下载安装就行https://nodejs.org/ 二、安装 gitgit 的软件很多，选一款你自己适应的就行。我用过，小乌龟tortoisegit，github，git，eclipe插件，idea插件，等等 hexo也有自带的，不装也行。为什么要安装 git 呢？客观的原因也没有深究。且来说说主观原因吧。 三、安装 hexo管理员权限，命令行：npm install -g hexo-cli，就安装好了，然后创建博客就行了。 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 更多详细配置看这里 https://hexo.io/zh-cn/docs/五、切换主题hexo 官方提供了大量的优秀主题可以更换，当然也可以选择自己去写一个主题出来。我在官网看到一个 Next 主题，甚是喜欢，毫不犹豫就把主题给换了。 主题代码拷贝主题的拷贝也是直接使用 git 即可，首先进入到你博客的根目录，再打开 git-bash 运行git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题在博客根目录下找到 _config.yml 文件，找到里面的 theme，改为theme: next这时再运行一次 hexo s ，看看主题有没有生效吧。 六、发布博客到 coding 配置hexo deployhexo 提供了一个部署命令 hexo deploy，首先需要安装一下 hexo-deployer-git插件npm install hexo-deployer-git --save然后配置一下_config.yml 文件： 12345deploy:type: gitrepo: &lt;repository url&gt;branch: [branch]message: [message] 预览效果在 coding 上建立一个私人仓库，找到代码的 coding 地址，填好上面的配置，然后直接执行hexo deploy不出意外的话会让你填写 coding 的用户名和密码完成上传操作。如果你有配置 ssh 方式的话就更加方便了。这个时候再到 coding 对应的项目里面打开 pages 服务，根据 coding 建议，因为不是 jekyll 项目，所以需要再新建一个.nojekyll 文件（空文件就行，其实不建立也行），等上一会就能够访问自己的博客了。 coding会让你添加他们的官网在你的博客某个地方，算了，他们免费。我忍了。 附上我的个人博客对应博文地址：https://angualr2.top 申请这个域名是因为，我是java专业的，angular入门前端。仅此纪念。 阿里云搞活动，3块钱一年。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[博客详细配置，相信我你想要的配置都在这里]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E5%8D%9A%E5%AE%A2%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%EF%BC%8C%E7%9B%B8%E4%BF%A1%E6%88%91%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%2F</url>
    <content type="text"><![CDATA[因为我们是用工具hexo搭建的博客，主题用的next，所以你看这两个文档所有的问题都能解决。hexo： https://hexo.io/zh-cn/docs/next： http://theme-next.iissnan.com/getting-started.html 整理常用的功能：安装hexo： https://hexo.io/zh-cn/docs/创建网站和网站基本目录介绍： https://hexo.io/zh-cn/docs/setup.html网站整体配置： https://hexo.io/zh-cn/docs/configuration.htmlhexo常用命令： https://hexo.io/zh-cn/docs/commands.html我原来有网站，迁移到hexo： https://hexo.io/zh-cn/docs/migration.html配置你的文章模板等设置: https://hexo.io/zh-cn/docs/writing.html 安装next： http://theme-next.iissnan.com/getting-started.html#install-next-themenext设置：http://theme-next.iissnan.com/getting-started.html#theme-settings为博客增加百度统计： http://theme-next.iissnan.com/getting-started.html#analysis-system-baidu阅读次数统计： http://theme-next.iissnan.com/getting-started.html#leanclound-page-views设置 RSS: http://theme-next.iissnan.com/theme-settings.html#rss添加「标签」页面: http://theme-next.iissnan.com/theme-settings.html#tags-page添加「分类」页面: http://theme-next.iissnan.com/theme-settings.html#categories-page设置字体： http://theme-next.iissnan.com/theme-settings.html#fonts-customization设置代码高亮： http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme侧边栏增加社交账号链接： http://theme-next.iissnan.com/theme-settings.html#author-sites开启打赏功能： http://theme-next.iissnan.com/theme-settings.html#reward友情链接配置： http://theme-next.iissnan.com/theme-settings.html#blogroll腾讯公益404页面： http://theme-next.iissnan.com/theme-settings.html#volunteer-404配置站点建立时间： http://theme-next.iissnan.com/theme-settings.html#site-since订阅微信公众号： http://theme-next.iissnan.com/theme-settings.html#wechat-subscriber设置「背景动画」：http://theme-next.iissnan.com/theme-settings.html#use-bg-animation设置网站载入动画效果： http://theme-next.iissnan.com/theme-settings.html#use-motion增加评论系统： http://theme-next.iissnan.com/third-party-services.html#comment-system增加分享系统： http://theme-next.iissnan.com/third-party-services.html#share-system增加站内搜索服务： http://theme-next.iissnan.com/third-party-services.html#search-system增加数学公式显示设置：http://theme-next.iissnan.com/third-party-services.html#mathjax增加facebook sdk： http://theme-next.iissnan.com/third-party-services.html#facebook-sdk设置google站点管理工具Google Webmaster tools：http://theme-next.iissnan.com/third-party-services.html#google-webmaster-tools内建标签： http://theme-next.iissnan.com/tag-plugins.html#bootstrap-callout-example设置 「JavaScript 第三方库」： http://theme-next.iissnan.com/advanced-settings.html#javascript-vendors你又问题看这里：http://theme-next.iissnan.com/faqs.html]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让Baidu和Google收录你的Hexo博客]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F%E8%AE%A9Baidu%E5%92%8CGoogle%E6%94%B6%E5%BD%95%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[http://www.franktly.com/2016/07/06/%E8%AE%A9Baidu%E5%92%8CGoogle%E6%94%B6%E5%BD%95Hexo%E5%8D%9A%E5%AE%A2/]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“好朋友越来越少，好朋友越来越好”]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E2%80%9C%E5%A5%BD%E6%9C%8B%E5%8F%8B%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%B0%91%EF%BC%8C%E5%A5%BD%E6%9C%8B%E5%8F%8B%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A5%BD%E2%80%9D%2F</url>
    <content type="text"><![CDATA[“失去过许多朋友，因为我不善言谈，于是他们渐渐有了新朋友，把我遗忘。或者认为我孤僻高傲，我不会整天对朋友说我爱你这类好听的话来表达自己。真正的友情是平平淡淡以诚相待，不需要太过热情和亲昵。在我失落沮丧自负的时候多谢你从来没放弃过我。我给不了你太多，但有个词叫尽我所能。”01、深夜里倾盆大雨，你很想把雨声录音给谁听，但翻遍整个通讯录，都没有看到那个合适的人。想去看刚上映的电影，寻遍四周，也没有找到那个可以陪你的人。每个月的免费通话时长总也用不完，未读信息都是来自10086。开着qq，更多的只是习惯，而不是为了和谁聊天。即使微信里躺着200多个好友，你发一条朋友圈也不会超过10个赞。你不得不去面对身边的朋友越来越少的事实，但你却一点也不觉得难过和孤独。因为到了某个阶段，朋友少这件事，其实是你自己选择的。02、你接连数月每天都碰到一个人，于是你同他的关系便十分亲密起来，你当时甚至会想没有了这个人还不知怎么生活呢。随后两人分离了，但一切仍按先前的格局进行着。你原先认为一刻也离不开的伙伴，此时却变得可有可无，日复一日，久而久之，你甚至连想都不想他了。想了想这段话不无道理，就像张爱玲与炎樱的友情，两人相识于香港大学，念书时很是要好，胡兰成与张爱玲结婚的时候，炎樱还是证婚人。但后来两人分隔两地，感情疏离，老死不相往来。炎樱曾在信里问，为什么莫名其妙不再理我？张爱玲说：我不喜欢一个人和我老是聊几十年前的事，好像我是个死人一样。在十几岁的时候，和一个人做朋友的初衷很简单，无非就是因为我们一起上课吃饭去逛街，可以和彼此分享各自的小秘密，不管是风吹日晒也要在一起胡闹，每天形影不离，深夜互诉衷肠。但一旦分开以后，时间和空间距离的扩大，交集会变得越来越少，即使见面能谈起来的也都是过去，因为我们之间，根本没有未来。人到了某个阶段后，对自己想要的东西会越来越清晰，朋友也是一样。我天生不善交际，也不懂该如何维持一段关系。“你对我而言很重要”这句话无论如何都说不出口。“道不同不相为谋”，所以我们只能走到这儿了。 03、陈奕迅在《最佳损友》里这么唱:“一起走到了某个路口，是敌与是友。各自也没有自由，位置变了各有队友。问我有没有，确实也没有。一直躲避的藉口，非什么大仇。为何旧知己，在最后变不到老友。”你也好奇为什么当初那么要好的两个人，最后的结局依然是分道扬镳。但这两年随着年龄的增长，你也慢慢明白，之所以有些人没有留下，是因为我们于对方而言，还不够重要。能离开的，都是不属于自己的。或许真正的朋友之间，从来都不需要时时刻刻的黏在一起，也不是非得在一起做过多么轰烈的事之后才会无话不谈。而是你得意时，她发自内心的为你开心。你摔跤了，她第一个跑过来扶你起来。你发自内心的欣赏她，她对你也是真情实意从不假装。你们支持彼此的决定，哪怕那是错的，也要陪着对方去完成。恋人也许会被取代，玩伴也会随时更换，但你知道，还有一个人谁也无法替代。04、夜里怕打扰她睡觉，所以你不会轻易给她发消息，但在第二天一定会把录好的雨水拍打在地上的声音给她听。她知道你找不到人一起看电影，就在她的城市和你买了同一场次相同座位的电影票，在别人和同伴窃窃私语讨论剧情的时候，你们也在互发消息开始吐槽。她或许喜欢玩qq，所以你每天在线，她需要你的时候，随时都能找到。你或许喜欢微信，她很少给你点赞，但你知道，关于你的一切她都知晓。你不喜多言，她或许叽叽喳喳。但你们永远不担心冷场和失去，见面也不只是寒暄和尴尬。美国往事里面说，“当我对所有的事情都厌倦的时候，我就会想到你。想到你在世界的某个地方生活着，存在着，我就愿意忍受一切。你的存在对我很重要。”真正的朋友是在最黑暗的时候，陪你一起等天亮的人真正的感情是心在下雨的时候，甘愿为你撑伞的人这个世上，能为你留到最后的人是最少的，但却是最好的。人只有在最深的绝望里，往往看到的才是最美的风景。好朋友越来越少了，但好朋友也越来越好了。 END - 朋友很多，知交者少好友很多，知情者少情绪很多，分享者少缘分不多，知心就好情不论长，真心就好「 晚安」本文转自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个孩子的心愿（大冰，感动）]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E3%80%80%E4%B8%80%E4%B8%AA%E5%AD%A9%E5%AD%90%E7%9A%84%E5%BF%83%E6%84%BF%EF%BC%88%E5%A4%A7%E5%86%B0%EF%BC%8C%E6%84%9F%E5%8A%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[光阴如潮，大浪淘沙，未来未知的年月里，这本书一定会被湮灭。 但我祈愿这些歌能被传唱。 若有一天末法来临，人性扭变，风急雨骤天昏地暗。 愿这颗普普通通的种子，能被按图索骥的人们发现。 愿人们知晓。这个世界，曾经来过一个普普通通的好孩子。 善良是一种天性，善意是一种选择。善意是人性中永恒的向阳面。 选择善意，即选择天性，即选择光明。 或许也是在选择一种永恒吧……虽然人性在每个人身上的星辉闪光都只是刹那。 （一） 他们并排坐在小屋的角落里，神情紧张。 很局促，手都不知道该往哪儿放。 过时的提包，素色的衣裳，廉价的皮鞋…… 简朴却整洁，隐隐带着几分普通人的隆重。 一看就知他们并不常出门旅行，衬衫扣得严严实实，头发梳得一丝不乱，出差一样。 坐姿僵硬得很，应该没怎么进过酒吧，两个人只点了一瓶啤酒。 一进门我就看出来了，他们应该来自某个小城，安分守己了一辈子的工薪阶层。 但我纳闷儿的是，他们的反应为何那么奇怪？ 我刚一进门他们就死盯着我看，眼神里满是期待和慌张。 孩子的眼睛会发亮，我知道的，却是头一次在中年人眼中见到同样的光亮。 正月的丽江热闹，街上游人熙攘，大冰的小屋里热气腾腾。 人很多，连台阶上都坐满了，听歌喝酒聊天，恣意地享受这假日时光。 那天来的大都是眉飞色舞的年轻旅人，学生、职员、背包客，一个比一个年轻。 中年人只有他们这一对儿。 他们应该是夫妻。 我在他俩对面坐下，点点头，冲他们笑笑。 紧接着我吓了一跳，我的笑容有什么问题吗？为何他们仿佛受惊一样，紧紧攥住了对方的手。 两只手攥在一起，攥得发白，四只眼睛愈发闪亮，依旧死盯着我，好像钩子一样。 我们之前见过吗？ 出什么事了，为什么这副神情？ 还没等我开口询问，中年女人猛地吸了一口气，猛地吐出来一句话：终于找到你了，大冰。 她颤抖着声音探问：听说，你是个一诺千金的人…… 谁造的谣？我慌忙摆手，手刚摆了两下就僵在半空中。 她双手合十面向着我，仿如佛前祈愿一样。 她闭上眼睛对我说：求求你……求求你帮我们一个忙。（二） 在他们开口讲述的头半个小时里，我并不知道自己会遭遇一个如此虐心的故事。 这是两个农村中学教师。 他们箪食瓢饮在浙江省青田县海口镇，教书育人，安贫乐道。 此次丽江之行是专程为我而来。 他们说，希望我帮他们一个忙，帮他们的儿子一个忙。 儿子叫越阳，1998年10月13日出生，90后。 他的母亲看着我的眼睛，着重强调说：越阳是个好孩子。 每个父母眼中的孩子都是好孩子，但她执拗地说，他们家的好孩子和别人家的不一样。 她说她的儿子出奇地懂事。 他们都是农村中学教师，陪学生的时间多，陪儿子的时间少，但儿子从小不哭也不闹，早早地学会了一个人吃饭，一个人睡觉。 早上睡醒，自己乖乖地穿好衣服，轻手轻脚地去上学。 问他，他会说，爸爸妈妈上班累，多休息一会儿吧…… 她说：我是老师，没时间过3月8日的节日……下课铃一响，就看见儿子站在教室外，一边挥动着节日卡一边喊：妈咪，节日快乐！ 节日卡是他自己裁的，自己画的，还有一只小蛋糕，他零花钱少，只买得起拳头大的蛋糕。 女学生们围着他，逗他，他一本正经地拤着腰，挨个儿教育她们：你们这些妇女啊……都要听话，不许惹我妈妈生气！ 他说，我妈妈很辛苦的…… 这个母亲讲着讲着，声音弱了下来，双眼失神地看着我，不知在想些什么。 我咳嗽了一下，她好像被惊醒了一样，歉意地点了下头，继续开口讲。 她说：别人家是妈妈哄孩子，我们家是孩子哄妈妈，从小就是这样。曾经有一个周末的晚上，我带着越阳去火车站广场玩，那时候他还很小……我太粗心了，边散步边在心中备课，不知不觉就和他走散了。我满广场找他，找遍了整个广场也不见踪影…… 我不知所措了好久，等到终于稳下心神想报警时，电话来了。越阳在电话里大声喊：妈妈，我找不到你，我自己先跑回家了，我在咱们家楼下的小店里，很安全的！ 越阳气喘吁吁地喊：妈妈你别担心我，你不许哭啊。 那个母亲说到这里，声音明显地沙哑起来。 看得出来，她在努力地平抑着情绪。 我递给她一杯水，她接过来捧在手里，却不喝。 她认真地看着我说：真的，他从小就知道心疼人。 我说：哦，我知道你儿子是个好孩子了，但是…… 她急急地打断我的话，自顾自地重复着说：他真的从小就知道心疼人…… 她急切地说： 我们越阳学习永远名列前茅，我们从来没操心过他的成绩，只担心他的喜好是否太多。学校里，他什么活动都乐意参与：广播站、学生会、演讲比赛、朗诵比赛、数学竞赛…… 光是象棋比赛的证书就有厚厚一摞。 象棋教练说越阳是棵好苗，让我们送他去省城好好培养。 但越阳拼命对我说，不要不要，妈妈，我下象棋只是兴趣爱好。 他怕让家里花钱，他怕累着我们，他心疼我们…… 越阳还喜欢音乐，学过小提琴，萨克斯考取了十级证书，葫芦丝在浙江省民乐比赛中拿过三等奖。 拿完奖之后他就不肯再学了，老师怎么劝他也不听。 他跟我说，其实乐器里，他最喜欢的是吉他。 他不说我也知道……学吉他最省钱，不像小提琴、萨克斯的课时费那么贵。 我当然不肯让步，哪个父母愿意委屈了自己的孩子？砸锅卖铁也不能耽误！又不是借不到钱…… 他搂着我的脖子说悄悄话： 妈妈你知道吗？我觉得音乐这东西很神奇，不论用哪种乐器去演奏，里面的道理都是一样的。你就让我学吉他吧，至于其他的乐器，我将来一上大学就自己挣钱……我有大把的时间去学。 我搂紧他：好孩子，爸妈没本事挣钱，委屈你了…… 他撇嘴：妈妈你说的这是什么话？谁有咱们家这么厉害——我爸爸妈妈都当老师！ 越阳学吉他上手很快，他本就有音乐天赋和功底。 吉他是借的，他总是说自己技术低，用不着专门买好琴。 别人还在爬格子、练和弦时，他已经开始自己琢磨着写歌了。他看书多，歌词一写就是半个笔记本，只等着将来学全了乐理就自己谱曲。 他志向大得很，当作家，当棋手，当歌手……那么多兴趣爱好，却未曾耽误学习。他后来从青田小镇考到省城中学时，成绩是最优秀的！ …… 每个母亲都爱夸自己的儿子，一夸起来就刹不住车，这个母亲也不例外。 这个朴素的母亲告诉我，他的儿子越阳考上的是赫赫有名的杭州市文晖中学。 很奇怪，讲这段话时，她的表情是骄傲的，声音却开始哽咽。 沙哑的哽咽。 ……据说去学校报到时，越阳手里的行李是最简朴的，肩上的行李也是最特殊的。 是一把吉他——为了庆祝考到省城，父母送他的礼物。 从小到大，他收到的最昂贵的礼物。 他弹着那把珍贵的吉他，从初一弹到初二。 从2012年弹到2013年。 （三） …… 2013年发生了许多事。 厦门BRT快线（厦门市快速公交系统）起火，47人殒命。 上海和安徽两地率先发现H7N9型禽流感，后续是江浙皖鲁闽，以及台湾。 大范围的雾霾笼罩中国中东部，从北京到上海，人们惶恐地抬头看天…… 这些公众领域的大事件被人关注、关心、铭记或遗忘。 2013年的杭州也发生了一件事： 一个孩子毫无征兆地病倒，一对父母一夜间忽然苍老。 没有几个人会去特别关注这件小事。 如无特殊原因，没有几个人会关心一个陌生的、普通的孩子的病症。 大部分人懒得去追问熟人社会以外毫不关己的事情。 大部分身体尚健康的人，并不关心这种病的致病原因到底是什么。 也并不关心，为何在城市儿童中，这种病的发病率已上升了13%。 2013年，越阳15岁，白血病。 （四） 好似耗尽了全身的力气。 那个母亲虚脱地靠在了丈夫的肩头。 她流着泪说：大冰，在来找你之前，我们俩读了你的书。我记得你在书里写过：……命运善嫉，总吝啬赋予世人恒久的平静，总猝不及防地把人一下子塞进过山车，任你怎么恐惧挣扎也不肯轻易停下来，非要把圆满的颠簸成支离破碎的，再命你耗尽半生去拼补…… 她靠在丈夫的肩头流泪，反复念叨着“命运善嫉”这四个字。 她说：到底嫉妒我们什么？我们到底做错了什么，非要惩罚这么好的一个孩子…… 最触目惊心的，莫过于中年人的伤心。 一对中年夫妻摊开手掌，彼此给对方拭泪，边叹气边拭，越拭越多。 这一幕看得我有些难受，但更多的，是一种难言的尴尬。 犹豫再三，我说：大姐，你们的遭遇我很同情，我知道治白血病要花很多钱，也大略知道你们的收入水平，但是实话实说……不是我见死不救，这个忙，我或许很难去帮。 我说：对不起，越阳是个好孩子，但我并不是个有钱人。 他们俩连声说“不不不”，用力地在我面前摆手。 那个父亲苦笑着说：大冰你误会了，我们不是来找你要钱的，我们当了一辈子教书匠，穷归穷，骨气还是有的…… 况且，他轻声说，我们越阳，现在不需要钱。 大过年的，你们不在医院陪孩子，反而千里迢迢跑来找我？ 不需要钱，那需要什么？ （五） 那位父亲揽住妻子的肩膀，再次帮她擦了擦眼睛。 他抬头看我一眼，又低下头，慢慢地说：……儿子很乐观，他妈妈都要崩溃了，他还反过来安慰她，变着法子逗她开心。他从小就这么懂事，生病了还这么懂事，他越这样，越让人心疼…… 这是个遭罪的病，生病的这两年，越阳尝尽了各种化疗的苦，每天吃药打针抽血……但化疗间隙病情较轻时，他总不忘学习，我们给他请了家教，文化课与吉他两不耽误。 医院里的人都喜欢他，护士喊他小鲜肉、小粉团，他给大家弹吉他，大家都给他打气，他也坚信自己能好起来，经常对我们说，等我病好了怎样怎样…… 2014年5、6月份，越阳的病情确实好转了，还重返了教室，上午上半天课，下午在家休息，期末考试竟然还考出了非常好的成绩！我儿子是最棒的，从小就是这样，不管生不生病都是这么棒！ 听到那个父亲说到这里，我松了口气，一句“恭喜”还没来得及出口，又生生咽了回去。 那个父亲低着头，愈发佝偻了，鼻尖上清清楚楚悬着一滴泪。 ……我们以为他几乎痊愈了的时候，7月份的骨穿报告也出来了。 骨髓里的坏细胞有点儿反跳，医生建议要连续加打四到六次化疗才行。于是我儿子又开始了连续化疗的历程，很痛苦，不是人遭的罪，那么小的孩子…… 前四次化疗进展很顺利，每次都完全缓解。 第五次化疗后，他妈妈拿到骨穿报告，哭得肝肠寸断！我也被这个晴天霹雳轰得差点儿晕倒。 天大的玩笑！这次骨髓里的坏细胞比7月份那次要高得多，是真正意义上的复发！ 瞒不住了。 我把这个复发的坏消息告诉儿子，他竟然出奇地平静。 他对我说，爸爸，没关系的，咱们再接着化疗。我憋着眼泪躲到门外去哭。 孩子，你和我说话的口气像个成年人一样，你为什么这么懂事？你难过你失望你哭你叫你喊出来啊，爸爸不怪你啊，为什么反倒要你一个孩子来安慰爸爸…… 化疗越多，对人体的伤害越大，恢复起来也越难。 其实他已经对化疗很恐惧了，每一次都是上刑啊……我不明白，他一个小孩子到底是靠什么才忍下来的。 儿子再次住进浙江省第一医院。 而我则跑北京、跑河北，联系骨髓移植事宜，必须骨髓移植了，没有别的办法了。医院联系好后，我把我们一家人的衣服和被子都托运到了河北那边…… 一切准备就绪，只等儿子这次打完化疗，细胞涨上来，就去医院做移植了…… 我们一家三口也都抽血进行了骨髓配型，结果都是五个点半相合，还是有希望的。 结果希望没了。 医生下达了病危通知书，说我们的儿子很快就要没了，让我们准备后事。 我们不懂呀，什么叫快没了？ 准备什么后事？不是还好好的吗？刚刚还说晚饭要吃大馄饨呢！我不信！ 他养病期间不是还在好好地继续写歌唱歌弹吉他吗？他将来还要继续上初中、上高中、上最好的大学…… 他还要继续玩吉他、在大学里组乐队，谈恋爱、结婚…… …… 是我们当爸爸妈妈的无能啊！ 你走了，我们也不想活了。 儿子的身体越来越难受，可他一直说：妈妈，我不难受，过两天细胞涨上来就好了，你不许哭。他想给妈妈擦眼泪，手都抬不起来了…… 儿子在他妈妈怀里睡着了。 我们等着他醒过来。 这么懂事的好孩子，我们等着他醒过来…… 我看着那个父亲，等着他继续往下说，但他久久没有开口。 喧嚣的丽江正月，街上的嬉闹声声声入耳，小屋里却一片沉默。 （六） 2015年2月11号，奇迹没有发生。 越阳没有醒过来。 1 越阳的遗愿，和我有关。 这是一个任性的遗愿。 他的母亲对我说，儿子弥留之际，曾留下几句话。 他说：好遗憾哦，这么快就离开这个世界了，还没来得及留下点儿什么，就要走了。 真的好遗憾，还有那么多没来得及实现的心愿…… 他说他写了好多歌词，但看来没有机会谱上曲子了，如果有人能把这些音乐给做出来，该多好啊…… 他说：妈妈，能让我任性一次吗？ 他说：妈妈，有一个人，他既是作家也是歌手，我读过他的书也听过他的歌。这个人神出鬼没，很难找到，但是妈妈，你去帮我找到他吧，一年不行就找两年……把我的歌词交给他，他会懂的。 他说：我看过他的书，我猜他会答应的。 他说：妈妈，我的好妈妈，我从没求过你什么，我一辈子就任性这一次，你们一定要帮我去完成这个心愿，好吗？ …… （七） 正月里的丽江，人群早已散去的小屋。 越阳的父母忐忑地看着我，沉默地看着我，双手合十，泪眼婆娑。 可怜拳拳父母心，他们应该是一料理完后事，就赶来云南找我的。 捧着两颗碎了的心，带着一个任性的遗愿。 他们下定决心要完成这个任务，云南找不到我就去山东，山东找不到就去北京，北京找不到就去西藏…… 上天安排他们在我启程回北方闭关前的最后一天找到我。 越阳一定没有想到，他唯一的一次任性，留给他伤痛中的父母多少折腾。 我可以拒绝一个16岁的孩子最后的任性，哪怕他真的是个罕有的好孩子。 但哀莫大于中年丧子，我没有任何理由去拒绝这样一对父母的请求。 我接过了一个U盘。 我说：好的。 （八） 我以为U盘里只是歌词。 不承想，歌词文件夹里还夹带着几段话，是16岁的越阳在得知病情复发时悄悄写下的，大意如下： 如果我真的运气不太好，挂了， 我愿意无偿捐献我的眼角膜和器官给需要的人。 我生病后，很多人给我捐款，把剩下的钱给其他白血病孩子用吧。 …… 爸爸妈妈去领养一个妹妹吧，我从小就想有个妹妹，你们知道的。 还有，我从小还想养只猫猫或狗狗，请妈妈帮我养一只吧。 …… 这个也是我的遗愿，我有好多歌词，其实我是可以用吉他弹唱出来的，但是貌似目前还不怎么会写谱。希望这些歌能被做成音乐，然后任何人都可以拿去使用（算是版权授权吧）。 我只是想留下些什么，爸爸妈妈一定要帮我实现啊，这毕竟是我最后的心愿了。 孩子，不管你最后的心愿有多么任性，他们都会帮你去实现的。 谁让他们是你的爸爸妈妈…… （九） 一开始，我以为这就是越阳“最后的心愿”。 直到几个月后的一天，我才发现自己错了。 U盘歌词文件里还有一个隐藏文件。 里面藏着另外一段话。 越阳的父母，我想，或许到了应该让你们看一下这段话的时间了。 冰叔，如果你发现了这些话，请在我走后半年，再给我爸爸妈妈看。 …… 爸爸妈妈，你们好一点了吗？ 真希望你们能早点好起来，一定不要陪我去了。 因为妈妈说过的，如果我死了，她也不活了…… 原谅我的任性。 原谅我留下的那些心愿。 我只是想，如果用“让你们帮忙完成我的遗愿”为理由的话，或许可以拖住你们一段时间吧。 就算是我自私吧，让我一个人走吧，让爸爸妈妈留下。 把歌词变成音乐，应该能够拖住你们一段时间吧，一定要帮我实现啊。 我走了，就让我的歌陪着你们吧。 还有一个拖住你们时间的办法，我从小就想有个妹妹，爸爸妈妈领养一个妹妹吧，把我剩下的一切都给她，这样你们就都能有个完整的家了。 我从小还想养只猫猫或狗狗，请妈妈养一只吧，也许我会投胎成一只小猫或者小狗，再多陪伴你们几年。 爸爸妈妈，来生咱们还是一家人，好吗？ 不管有多难我都会找到你们，继续当你们的好孩子。 …… 请允许我解读一下这段文字。 他确实很任性。 他处心积虑，其实心愿只有一句：希望爸爸妈妈好好活着。 （十） 我不是一个多么好的歌手。 我也不是一个多么好的作家，甚至曾经一度也不是一个好孩子。 但是我知道这样一句话： 善良是一种天性，善意是一种选择。 善意是人性中永恒的向阳面。 我从未想到过，这句话会在一个16岁临终少年的身上得到印证。 他如流星般划过，却用善意短暂点亮了夜空。 是的，人性在每个人身上的星辉闪光都只是刹那。 但正因为有了那一刹那，有些人才变得永恒或伟大。 命运善嫉，这个16岁的少年一定来不及伟大。 但他所选择的善意是永恒的。 （十一） 越阳的音乐做好了。 我履行承诺，找到了越阳所钟爱的民谣歌手们，把他的部分歌词编曲谱曲，并演唱录音。 越阳的生日是10月，秋天。 届时，半年之期已到，这本书也应该已经上市了吧。 这篇文章的末尾，我会摆上他的音乐的二维码。 就当是送给他的生日礼物吧。 这也是他留给这个娑婆人世间的礼物，送给每一个人的。 光阴如潮，大浪淘沙，未来未知的年月里，这本书一定会被湮灭。 但我祈愿这些歌能被传唱。 若有一天末法来临，人性扭变，风急雨骤天昏地暗。 愿这颗普普通通的种子，能被按图索骥的人们发现。 愿人们知晓。 这个世界，曾经来过一个普普通通的好孩子。 P.S.（附言）： 遵从越阳的遗愿，歌词版权开放，谁都可以谱曲，谁都可以演唱。 我奢望下面这份感谢名单可以更长。 感谢我的姐姐？成方圆 感谢我的兄长？水木年华·卢庚戌 感谢我的兄弟？麻油叶·马 感谢我的弟弟？好妹妹乐队·秦昊 感谢我的兄弟？游牧民谣·王继阳 感谢我的兄弟？赵雷（手风琴：齐静，贝司：旭东，混音：姜北生） …… 感谢你们百忙之中的仗义出手，亲自将越阳的歌词谱曲演唱。 替孩子谢谢你们，替孩子的父母谢谢你们。 大冰于此稽首百拜。 江湖儿女江湖见，恩义必当后报。]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个优质男朋友的标准]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E4%B8%80%E4%B8%AA%E4%BC%98%E8%B4%A8%E7%94%B7%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不管怎样，你要善良]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E4%B8%8D%E7%AE%A1%E6%80%8E%E6%A0%B7%EF%BC%8C%E4%BD%A0%E8%A6%81%E5%96%84%E8%89%AF%2F</url>
    <content type="text"><![CDATA[人们经常是不讲道理的、没有逻辑的和以自我为中心的 不管怎样，你要原谅他们 即使你是友善的，人们可能还是会说你自私和动机不良 不管怎样，你还是要友善 当你功成名就，你会有一些虚假的朋友 和一些真实的敌人 不管怎样，你还是要取得成功 即使你是诚实的和率直的，人们可能还是会欺骗你 不管怎样，你还是要诚实和率直 你多年来营造的东西 有人在一夜之间把它摧毁 不管怎样，你还是要去营造 如果你找到了平静和幸福，他们可能会嫉妒你 不管怎样，你还是要快乐 你今天做的善事，人们往往明天就会忘记 不管怎样，你还是要做善事 即使把你最好的东西给了这个世界 也许这些东西永远都不够 不管怎样，把你最好的东西给这个世界 你看，说到底，它是你和上帝之间的事 而决不是你和他人之间的事]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[他喜不喜欢你，看聊天记录就知道]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E4%BB%96%E5%96%9C%E4%B8%8D%E5%96%9C%E6%AC%A2%E4%BD%A0%EF%BC%8C%E7%9C%8B%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%B0%B1%E7%9F%A5%E9%81%93%2F</url>
    <content type="text"><![CDATA[人的倾诉欲是有限的，我们往往只想和喜欢的人说更多的话。而在越来越繁重的生活里，每个人都变得很忙，交流也变得更为珍贵。 没有人是不忙的。 但为什么总有人，他整天像个没事儿的人一样，找你说不停的话。一遍一遍问你在干什么，吃饭了吗。还会把一点点小事都和你唠叨。 喜欢和你说话的人，我想他是喜欢你的。 02 那天喝下午茶，我看到朋友对着手机认认真真在聊天。我打趣地问她，“是哪位追求者啊”。她把手机递过来，示意我自己看。朋友上下划了两页，我就明白了。 不是她的追求者，而是她在追求别人。 或者明白一点说，她喜欢对方，而对方，回应很勉强。 我问她，“这是你喜欢的男孩吧”。 她点点头，问我怎么看出来的。 很简单啊。 两页聊天记录里，总是朋友说得比较多。对方的回应最多是，“恩”，“好的”，偶尔在玩笑处回应“哈哈”。 看着都挺尴尬吧。 朋友发了一大串话，对方回复了一个“恩”，朋友还能继续说。这还不是喜欢？ 03 我想了想，聊天记录真的能看出两方谁用了比较多的感情。 和喜欢的人聊天，一页一页翻下来，总是我说得多，他说得少。和喜欢自己的人聊天，总是对方说得比较多，而自己的回应很少。 大概只有在和喜欢的人聊天时，人才会变得滔滔不绝。而面对不大有感觉的人，通常惜字如金。 对喜欢的人，迫不及待想要开始一段对话。于是忍不住就要主动找他。也在最后，舍不得自己先结束对话。 开头是你，结尾也是你。 对不太有感觉的人。不想开头，只想快点结束。于是一句“我去洗澡了”，就差不多结束了对话。 这是为什么，一个人能洗澡洗一晚上的原因。只是他不想再和你继续聊下去了。所以没有“我洗好了”。 喜欢你，才会找你聊天。不喜欢你，就会满屏只有你自己说的话。 他喜不喜欢你，看看聊天记录吧。 晚安。 本文来自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[他爱你就一定会来找你]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E4%BB%96%E7%88%B1%E4%BD%A0%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%9D%A5%E6%89%BE%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[有人说，爱你不一定会主动找你啊。总有些人是宁愿失去也不主动的类型。相信我，那只是一小部分人，他们瞻前顾后，担心太多。换句话说，或许是他还不够爱你。我想更多的人，在喜欢的人面前，还是忍不住不打扰。要忍住那种很喜欢的感觉，不光难受，也很困难。小安昨天谈恋爱了，男友Z先生曾和她有长达半年的暧昧期。之所以在昨天突然就确定下来，还要感谢一个不知名的男孩。那个男孩是小安朋友的朋友，几次吃饭几次聚会就熟络了起来。但小安说，她还是不记得男孩叫什么。Z和小安是一个朋友圈子里的，他们认识好几年了，半年前才开始暧昧起来。那个不知道叫什么名字的男孩应该是对小安有好感，聚会时就一直照顾着小安。吃饭也好，唱歌也好，挡个酒递个水果什么的，贴心至极。小安心想，z半年来总是没表明过态度，自己想谈个恋爱，觉得这个男孩也不错，也可以试着接触一下。毕竟爱情这事，还是得两情相悦。就接受着男孩对她的好。在外人看来，他们的行为也有些暧昧的意思了。身边越来越多人开玩笑，说小安和男孩是一对儿。这话当然也传到了z先生耳朵里。那段时间小安和z先生接触不多，只知道他开始隔三差五找人喝酒了。一直到昨天。昨天凌晨3点，小安正和我们开群语音，突然就掉了线。5分钟之后她回来宣布，她和z先生在一起了。我们逮着她问事情的来龙去脉，才知道了结果。原来z先生之前和她暧昧就是因为他喜欢小安，但是又不确定有多喜欢。按他的话来说，就是没有喜欢到一定要和小安在一起的程度。直到那个男孩出现，那种要失去小安的感觉让他知道，他其实远比自己想的喜欢她。他和小安说，“我受不了你和别人在一起，所以我一定要和你在一起”。你看。他喜欢你，他爱你，就一定会来找你的。你也不用再对着电脑那边没有音信的对话框发呆。也不必再熬夜等他几年一次的晚安。你不用安慰自己说他的冷淡是天性，也不要再为他迟迟不表态而找借口。他不再对你说，“你在干嘛”了，因为他开始对别人说了。他不和你说晚安了，不是因为他忘了，而是因为他已经和别人说过了。他一直也和你暧昧着，总是不表态，不是因为他害羞而不敢表达。是因为，他真的不够喜欢你。比你想的还少。也或者，他只是喜欢暧昧，你也只是几分之一。他爱你，一定会来找你。他不爱你，你等也等不来爱情。 晚安，想梦见你。]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[喜欢上你，我就变成了傻子]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E5%96%9C%E6%AC%A2%E4%B8%8A%E4%BD%A0%EF%BC%8C%E6%88%91%E5%B0%B1%E5%8F%98%E6%88%90%E4%BA%86%E5%82%BB%E5%AD%90%2F</url>
    <content type="text"><![CDATA[其实我一直很喜欢长头发的姑娘，可我偏偏是一头短发。一短就是两年。原因啊，大概就是因为我喜欢的男孩，他说我短发好看。于是当初我就剪短了及腰的长发。 见过朋友的某任女友，姑娘很可爱。在公司担任的职位不低，可见还是非常能干的。能干的含义不光包括能力高，还包括情商和智商也不低。可总听见朋友说，“她有时候真的好傻”。 朋友爱打游戏，姑娘就下了班陪他打到很晚。朋友随口一说喜欢那个牌子季度的新款，姑娘就花了几千块买了那件T恤。朋友说姑娘头发的颜色不好看，姑娘就去换了发色。那件朋友说不好看的衣服，我就再也没见她穿过。 你看，他喜欢什么，她就想给他。一个25岁的姑娘为了男朋友折1000颗小星星的事，画面有点不可思议。但她就是这样做了。 朋友睡不着，她就陪他聊很长很久的电话。朋友喝醉了，她就凌晨打车去接他。姑娘说，因为喜欢他，觉得自己变成了傻子。可还是想把能给他的，能让他开心的，都尽量给他。 后来他们分手了，朋友说，还是觉得自己是不喜欢她的。疯狂的，都是不被爱的。被爱的，往往理智又冷漠。 那时我看过很多技巧类的文章。比如“如何保持恋爱中的新鲜感”，比如“如何维持长期的恋爱关系”，再比如“如何在一段恋爱关系中保持平衡的位置”。可当我真的处于一段爱情中，在面对喜欢的人的时候，我还是忍不住看着他就傻笑出声。什么技巧，我根本就不记得了。我只会茫然失措，只会把他所说的每一句都记清，然后给他我能给的所有。 别人也夸赞我是个聪明的姑娘。但喜欢上你，我就变成了傻子。我想啊，这应该就是爱情的可爱之处。再精明的人，遇到喜欢的人了，也不会再多于计较。 我傻，还不是因为喜欢你。要是不喜欢你，我理智得自己都害怕。 晚安，想梦见你。 本文转自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[寻人启事--大冰]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E5%AF%BB%E4%BA%BA%E5%90%AF%E4%BA%8B--%E5%A4%A7%E5%86%B0%2F</url>
    <content type="text"><![CDATA[看的懂的，都不是命运。说的清的，都不叫爱情。忘的了的，都不是遗憾。听的见的，都不是伤心。躲的开的，都不是缘分。猜的透的，都不叫人生。 海鸥在飞。现在是2016年2月10号，正月初三。德雷克海峡风速30节，浪高9米。船颠簸的像过山车，偶尔有冰山在不远处飘过，穿越这片沉船无数的海域，前方是南极。 整整四天，没有网络信号也没有手机信号，整船的人与文明世界暂停了联络。四天的时间，我攥紧手机坐在后甲板上打字，风浪里写下这篇正在进行式的故事。晕船的人们在我身旁哼唧，他们艰难的问：Hi,ICE,你在写什么？我说：寻人启事。 寻的是一个故事的结尾，找的是两个吹泡泡的孩子。 1左手是筷子，右手是碗和蒜。腊月里的一天，我蹲在门口吃面。吃面就该大口吃，尤其是西红柿鸡蛋打卤面，微酸微咸却又鲜甜，滚烫滚烫的好似初夜……咔嚓，再啃一口蒜。 那个高个子男生走过来，并排蹲到我身边，冰叔，还记得我不？长长的一口面挂在嘴上，我甩着面汤点点头……你好你好，你哪位？他失望地撇了一下嘴：我在小屋过了三次春节了都，包饺子放鞭炮咱们都是一起……他摇摇头，沉重地叹了口气：你不记得我了…… 添堵来了？没看见我正吃饭呢吗？面碗扣你脸上信不信！每年被我捡回小屋一起过除夕的孩子有十几个，这么多年下来哪儿能记住那么多？有人在我这儿过了六次春节都还叫不上名呢，你委屈个溜溜球啊你。 他慌忙解释：没委屈没委屈……只是，如果留的印象这么不深，那有些话怎么好和你提…… 想提什么？又是来借钱滴？愁死我了，我向来反对盲目地辞职退学去流浪以及什么狗屁说走就走的旅行，一切不负责任的穷游都是在对自己有限的青春耍流氓懂不懂……你们这帮熊孩子啊，又是穷游缺盘缠了是吧？有困难自己摆摊儿卖装备、打工刷盘子挣钱去，我又不是开银行的，怎么可能天天江湖救急给你们当提款机？ 男生慌忙摆手，我咋会是来要钱的……我只是想请你拿个主意！头立马大了，赶紧端起碗跑，不跑不行，看来又是来找我探讨青春的迷茫、理想的遥远、生活的困惑的伤感文青……但我一不是垃圾桶，二不是心理辅导员，三不是午夜情感电台的知心大姐，我自己个儿还没活明白呢，有什么资格给你指点迷津？ 哎，你拽我裤腿子干吗？撒手！面汤浇你一脑袋信不信！大个子男生吭哧半天，仰着的额头上憋出来一层汗。半晌，他艰难地开口：叔啊，我今天来的目的，和那个姑娘有关…… 姑娘海了去了，哪个姑娘？叔，就是那个神奇的卉姑娘。 2好几年了，卉姑娘每年都会出现，每次都是除夕前的三天。 除夕之前，许多人都会专程赶来小屋。大都风尘仆仆，大都单身一人，大都是孤儿。这是小屋多年的传统：除夕不打烊也不做生意，大门敞开，收留无家可归的孩子。 和情怀无关，也并非悲悯，结个小善缘而已。小就是不深不浅，善就是天性使然，缘就是聚合离散。有戈壁就应有绿洲，有沧海就该有礁屿，前路远且长，总有些单飞的鸟儿乏了累了，那就来嘛，停下来歇歇脚，攒攒心力。收留族人本就是小屋存在的意义之一。来嘛，一起放鞭炮一起包饺子，一起抱团取暖，再各奔东西。 大年下的，有家没家，总要吃顿饺子。每年除夕一起吃饺子的人很多，可惜我神经大条、记忆力低下、脸盲症严重，大多嗯嗯啊啊记不住姓名，可唯独对卉姑娘例外。 神奇的小卉姑娘是个谜。张卉王惠刘辉李绘赵慧？不知道。哪里人？什么星座？搁哪儿上大学？学的啥专业？现在做啥工作？不知道。问她也不说，她话极少，只是笑眯眯地揉揉鼻子，含含糊糊地嘟囔一声：哦……头发垂下来，轻轻遮住眼，睫毛扑闪扑闪，让人不知不觉就心软了。没人会舍得继续逼问她。没办法，谁让人家真会打扮真好看。 卉姑娘真好看。哪种好看？第一眼哦还行，第二眼哎哟不错哦，第三眼啊呀我去咋这么好看的那种好看。眉毛也弯弯，睫毛也弯弯，一头Biu Biu的小自来卷儿晃呀晃，橱窗里的洋娃娃一样，刚出炉的小蛋糕一样，看起来很好吃的那种好看。长相如果70分，打扮就又加了30分，小靴子小裙子小绒帽小披肩，洋气得嘞。同样是粉底口红假睫毛黑眼线，搁在有些人脸上像极了葫芦娃的女主角，可搁在小卉这儿，却分寸把握得舒服得当又自然，怎么看怎么养眼。同样是化妆，和她一比，别人成了刷墙。 越是美好的事物越是有着耐人寻味的地方，卉姑娘也不例外。她有许多很神秘的地方，比如永远戴着小手套。屋外也戴屋里也戴，也不怕焐得慌。有时是皮的，有时是布的，有时候是毛线绒绒球的，包饺子时也戴着手套，医院里用的薄薄的胶皮的那种。她24小时细心呵护，裹得严严实实的，没人有机会看到她的手到底娇嫩成什么样。 戴手套的原因怎么问她也不说，只是笑眯眯地揉揉鼻子，含含糊糊地嘟囔一声：哦……我和她开玩笑：卉，你是个江洋大盗吗？手保护得这么好是为了保持敏锐度吗？好用来拧金库的密码锁是吧，电影里演的那样？她腼腆，喜欢捂着嘴笑：叔的脑洞好大。 啊哈小卉，那你是个手模是吧，手是不是上过保险啊，是不是还需要天天在牛奶里泡？她抿着嘴笑：牛奶泡手啊，太浪费了才舍不得呢……我说：浪费啥，用两块钱一袋的那种不就得了。她摇头，那也浪费……语气不是在矫情，表情也不是假的，那小眉头皱的，看来是真的在心疼牛奶。但“浪费”两个字从她嘴里说出来总让人感觉怪怪的，从衣着打扮来看，小卉的经济状况应该不是一般地好，她这样漂亮精致的小白领还会吝啬两块钱一袋的牛奶？这么惜财，我猜她是金牛座。 事实证明，卉姑娘其实是大熊座。她力气太大了！这是她第二个奇特的地方。大年三十的年夜饭需要买够十几个人吃的菜，忠义市场离小屋远，石板路窄，车开不过来，只能靠人背。第一次背菜时就把我骇住了，小卉两臂一抡，力从腰起，嗖的一个漂亮的背篓上肩动作……熊的力量啊！一个背篓装满，几十斤重的米面瓜果菜，我背都吃力，她一个娇娇小小的丫头子是怎么做到的？ 练过摔跤吗？天生神力吗？来不及问她，她走得太快了，同样沉的背篓，我们四五个大老爷们儿喘得吭哧吭哧，人家姑娘边走还边哼着歌，脚下穿的还是高跟靴。怀里还比我们多抱了一头大冬瓜！ 脑补一下，一个你在大都市街头经常会遇到的那种白领打扮的漂亮小姑娘，穿着精致的小套装，背着冒尖的大背篓，咯噔儿咯噔儿地蹦跶在青石板路上，抱着冬瓜哼着歌，散步一样，跳宅舞一样。饶了我吧，这幅画面真的太二次元了。 我冲着她的背影叫唤：卉，你慢点儿你注意点儿形象好吗？你是码头扛大包的吗，你是建筑工地扛水泥的吗……你他喵的是个女的吗你！她嘎地刹住脚步，扭头笑笑，神情略微紧张略微尴尬。哎呀，她说，是哈，我今天的力气怎么忽然这么大……她抬手擦擦汗：唉，好沉啊……脑门上一滴汗都没有，装什么装？装又装不像，愁死我了你。 没人要求她背菜，她其实只是跟着来当当财务管管钱而已。其实她一进菜市场就已经把我给吓着了。菜摊前一站她就变身，菜贩子没有一个比她精，没一个能说得过她，她居然掌握我妈那一辈老太太的买菜必杀技——边翻边拣，边拣边贬，再新鲜的菜也先贬成没人要的烂菜叶子，充分打击完菜贩子的自信心后，慢悠悠地说，便宜点儿呗……不仅会杀价，她居然还会看老式木杆秤，还不停地唠叨说：高高的……菜贩子怒吼：够高了！她回吼：把你小拇指收回去，别压着！ 除了我三姨和我大姑以外，我活这么大就没见过这么会买菜的人，要不是那身洋气的小套装，真以为是俩职业菜贩子在搞业务切磋。难得难得，大超市惯坏了现代人，更何况真刀真枪砍价的说。时下的年轻小姑娘个顶个自称吃货，每个人的手机里都能翻出一堆美食照，可真要扔进菜市场，分分钟挂科，保不齐油菜当菠菜、山药当萝卜，更何况看秤的说。好吧，若买菜有职称，小卉应该是教授级别。 我拽拽卉教授，得了得了，人家也不容易，大年下的，别为了那块儿八毛的争急眼了……你省那几毛钱干吗？留着买别墅啊？她眼神中明显在心疼那笔巨款，不过倒也听话，不砍价也不唠叨了，只是临走时非要多饶一个土豆，还对菜贩子说：买了你这么多菜，你多给我们一个塑料袋子。 好神经的姑娘，几毛钱都不舍得，一个塑料袋子也不放过！ 3会买菜，会背菜，那会不会做菜？当然会，不然怎么叫神奇的小卉。那一年的团圆饭小卉主厨，她客客气气地把所有人撵出厨房，让我们到餐厅里包饺子去，然后把厨房门紧紧一关，谁都不让进，谁都不让看。难得难得，家境这么好的孩子居然还精通厨艺，小卉真不错，只是她把门关那么严干吗？做饭而已，又不是洗澡冲凉，有什么可保密的？…………水龙头哗哗淌，抽油烟机轰轰响，没过多久，菜香依次飘荡出来，好闻好闻，有鸡有肉有海鲜，一闻就馋了。我忍不住扔下擀面杖跑去推门，浑蛋，怎么还用拖把把门顶住了？搞什么飞机？我不吃我就光尝一尝行不行……开门！ 门没叫开，一堆人堵在门外咽口水，有些没出息的还趴在门缝上闻菜香。真的香啊，不是家常菜那种温馨体贴的香，也不是酒店酒楼里那种浓墨重彩的香，有点儿像学校食堂里那种接地气的香，可以狼吞虎咽，可以大撕大嚼，可以勺子刮着饭缸噌噌响，可以馒头蘸着餐盘擦菜汤。侧头看看两旁的人，像极了刚踢完球赛的大学新生，个顶个饥肠辘辘饿死鬼的脸，小卉好手艺，做菜懂得因地制宜，小屋除夕的团年饭可不就是食堂开饭吗……不行了，越闻越饿，我带头砸门，咣咣咣，大师傅，啥时候开饭啊哈…… 咣当一声，锅盖掉落的声响，卉姑娘隔着门结结巴巴地回应：快快快快了。 两个小时不到，小卉变了一场魔术，厨房里干干净净，餐厅里琳琅满目一大桌，全由她一个人搞掂。她一边调整着手上的胶皮手套，一边冲众人笑，好神奇，身上也是干干净净的，连个油点子都找不到，她是怎么做到的？ 眼前的餐桌热气腾腾，远处的鞭炮声隐隐约约，烟花开满落地窗，电视里热热闹闹地唱着歌……有眼眶浅的姑娘当时就忍不住了，眼泪稀里哗啦掉落：原来这就是家的感觉哦……我伸手拦住她的筷子：少侠，忍住！不忙吃，饺子还没包完呢，赶紧把鼻涕擤一擤，继续给我擀饺子皮儿去！ 小卉却说：大家先吃吧，我一个人来包就好了。逞什么能？十几张嘴几百颗牙呢，起码要包300个饺子，你累了半天了，赶紧躺沙发上歇会儿去。她不肯歇着，我卡着她的脖子把她推出去，她自己又颠颠儿地跑回来。我说，我打哭你信不信！她说信，于是怯怯地倚在餐厅门口揪手套，又远远地指指那些已经包好的饺子：这种包法，一下锅就开口笑了。 过年讲究吉利，她说的笑，是散的意思。细看看包好的饺子，真想掀桌子，天南海北什么籍贯的人都有，饺子自然也是千奇百怪的，有大有小有花边，有馄饨形状的，也有鱼丸模样的，奶奶的，还有心形的，陶艺课吗！……好吧小卉，你行你上吧。……小卉包饺子的技术好神奇，右手筷子左手皮儿，馅儿挑进皮儿里的同时，手嗖地一握，我的天，一个饺子包好了……我的天，机器人儿吗？一个一个接一个，长得一模一样的…… 那顿饭吃得香甜，男男女女打饱嗝。我端起杯子给小卉敬酒，辛苦了，好吃！……明年你来不来？明年你必须还来！我们等你哈，说好了哈。水晶杯叮的一声轻响，杯中绯红色的醇酒荡漾，莫名其妙，小卉的眼圈怎么也红了？她咬了一下嘴唇，小声问：……我真的可以再来吗？什么话！醉了吧，我送她一个大白眼儿：废话，咱们不都是一家人吗？想了想，又补充说：……最起码每年的这几天，咱们都是一家人。她使劲点头，小鸡啄米一样。她说：嗯嗯嗯，足够了足够了…… 门外开始点炮仗了，一堆人稀里呼隆地拥出去看热闹，小卉也跟着，姹紫嫣红里我回头，她独自站在屋檐阴影处的角落里。手套摘下来了。手摁在脸上，脸是湿的，左手擦完了是右手，右手擦完了换左手…… 大过年的哭什么哭嘛，怪让人心疼的……手绢掏出来，脚步却停下来了。哭就哭吧，这帮没有家的孩子。 ……小卉留下的小故事还很多。我脑洞大，根据种种迹象脑补出一个揣测：神奇的卉姑娘从事的工作，应该是餐饮行业，从采购到厨房，经验如此丰富，想必是父辈有意培养的，自然是从小耳濡目染得来的，我猜，她或许隶属于某一个家族连锁餐饮企业。豪门恩怨的故事不仅仅会在TVB电视剧里发生，她在她的家族里，或许也是个众矢之的的角色。寻常人家的孩子不会这么懂打扮，从衣着妆容可以看出，衣食一定是无忧的，但心情也一定是阴霾的。辞世的父母留下了产业，她刚成年，尚无力全权承接，有人觊觎没人罩着，谋她的人比帮她的人多……这种故事若按常规的走向，除非她自己加速成长，否则住别墅和住大杂院，不过是一线之间。 按这个揣测来解构，倒是容易理解她出类拔萃的自理能力，以及她的懂事和怯怯。每个人有每个人的心结和沉默，身世她不愿开口诉说，那就不说吧。 每个人是每个人的过客，鸟与礁，绿洲与骆驼。小屋和年夜饭，礁石而已，一年一度浮出海面生起篝火，只能提供短暂的温暖和停歇。 4高个子男生说：那年除夕，小卉偷偷躲在屋檐角落里哭，我看见了……忽然就关心上她了。男生说他一关心就关心了整整两年。 喜欢就说喜欢，什么关心不关心，真是个薄脸皮儿的男生。白搭，死了这条心吧！孩子你没戏的，不光是你，你们所有男生都没戏。小卉之所以叫神奇的小卉，还有一个重要的原因：没人知道她的过去，没人知道她任何身份信息，没人知道她每次来古城住在哪个客栈，甚至没人知道她每年会在大年初几忽然离去。 她享受小屋这种族人式的团聚，却排斥任何一种形式的联系。没有任何一个男生能成功留下她的手机号码，和她最要好的那几个女生都没她的QQ号码、微博、微信。再怎么套话，她也只是冲人家笑，嘴抿得紧紧的，一个字都不漏，和和气气地婉拒。 我拍拍那男生的肩，算了吧，拉倒吧，省省吧。看过画展没？参观者和艺术品之间永远要保持一点儿安全距离，好看就好好看，莫要伸手摸，同理，关心就默默关心，卉姑娘每年出现时都是同样的光鲜亮丽，知道她过得挺好就行，何苦操那么多心。 男生方（慌）了一会儿，反驳道：这个心我必须操……他说：只有我知道她的生日是每年的除夕！ 这么笃定的语气不像是瞎掰，轮到我方了。小卉姑娘的生日是除夕？过去几年她从未提及，×，那她岂不是好几年没吹蜡烛没吃蛋糕没许生日愿望了？是怕给我们添麻烦吗？是不好意思被人瞩目吗？这叫怎么个话说的…… 男生说，你没发现吗？每年的除夕，她都会独自躲到角落里哭一会儿，再自己给自己唱一会儿歌……他说，她唱的，是郑智化版的《生日快乐歌》。 她有在唱歌吗？别人都没发觉，连我都没发觉，怎么偏偏让你发觉了？她唱的是什么歌？男生说：因为除夕这天我我我……因为这首歌我我我……我什么我？有什么难言之隐吗？男生没有说，男生扭转话锋：冰叔，咱们不能再让小卉过不上生日了，你能不能拿个主意？ 我说走！买大蛋糕去！唉，浑蛋！你怎么又把我裤腿子拽住了？什么，不能买蛋糕？为什么不能买？ 男生嘴笨，组织了半天语言，方大体表明心意：小卉不肯公布生日，一定有她的原因，生日是一定要给她过的，但一定要过得巧妙才行，无论如何，既要让她过好今年的生日，又要让她不会感觉到丁点儿的不自在。他说他想了许久也没想出个靠谱的主意，所以今年预支了年假提前一周来寻我，希望我能给小卉一个完美的生日除夕。他手塞进领口，从内衣口袋里掏出一张农业银行的储蓄卡，说：这一万元钱是我准备的小卉生日经费，这钱您怎么安排都行，我相信您，但无论如何，小卉面前请替我保密。 保什么密？为什么要保密？男生的耳朵瞬间红了，脸却没红，一米八几的大个子，害羞害得好稀奇。 我捧着面碗，把那个男生看了半天：小伙子，看来你对卉姑娘动的是真心。既如此，钱他妈给我收回去，不就是出个主意吗？叔脑袋里除了糨子剩下的全都是主意。除了帮小卉生日出个主意，另外私人无偿奉送你小子一个主意。 你听说过五大人生建议没？条条都是真谛：1. 喜欢就买2. 不行就分3. 重启试试4. 多喝热水……还有5. 果断表白！ 大个子男生的耳朵由红变白，他低着头苦笑了一下，说：叔，你知道我是干吗的吗……他伸手比画了一个切菜的动作。他说：我是个厨子，刚出实习期…… 他苦笑：我一个月的薪水，估计都换不来小卉两双手套。他嘟囔：我这样的人，怎么能配得上她？ 5我隐约有印象了。想起来了，过去几年，每年的除夕团圆饭前，都有一个高高的身影蹲在门口忙活着净菜，有时候剥葱有时候捣蒜，有时候刮鱼鳞。小卉话少，他的话也不多，他的袖子好像总是挽起来的，很多准备工作他默默地就做了。…………总有一些人默默地躲在人群中，不声不响却又踏踏实实，他们站在焦点的外围，总是甘当配角。好似一只托盘，又好比一小片不起眼的胶垫，有他们存在的地方，酒是不会洒的，桌子也是稳的。不冰冷也不炙热，他们永远26摄氏度，总是恒温的。 小厨子，要想帮小卉过好这个生日，光我一个人的能力是不够的，你也帮帮忙吧。一张图纸搁面前，会蒸胶东饽饽大馒头吗？按这个图的样子去蒸吧，能蒸多大蒸多大！我又扔给他一张歌谱一把吉他，小厨子，还有一个星期的时间，好好练吧。他吓了一跳：我不会啊，从来没摸过吉他啊……没问题的，会唱这首歌就行。和弦都是最简单的，一个星期足够了，对别人我没信心，对你我信心大大的。你不是个鲁菜厨子吗？鲁菜刀工冠天下，切得了蓑衣黄瓜的手难道还拨不了吉他？ 七天的时光眨眼即逝，和往年一样，单飞的鸟儿们接踵而至，小卉也来了。米白色的羊毛小大衣，手套是粉红色的，人比去年消瘦了不少，却越发显得眉清目秀了。我说：卉啊，没事别瞎减肥哈，排骨永远不如五花肉实惠，网红锥子脸什么的最没劲了。她捂着嘴咯咯笑，又轻车熟路地翻出背篓：叔，我买菜去了。我说去吧去吧，多带几个人去扫荡菜市场，把门口那个大个子也带上……记住哈，大年下的，别往死里杀价！ 年夜饭依旧是小卉主厨，吃饭的人却并非同一拨。铁打的小屋流水的过客，有些人来了又来，有些人来过后再没来过。不是不长情，贺年短信还是发的，不过是告别了单身组建了家庭，各自找到了栖息地，不再需要礁石了而已。卉，和你同一年同一茬的那几个女生都已经把自己嫁出去了，没嫁出去的今年也是带着男朋友一起来的，你现在是啥情况啊？还是单身一个人吗？ 小卉姑娘不搭话，隔着厨房的门板，她假装没听见。我挠挠门：姑娘，我和你说哈，做人如果没追求，和咸鱼有啥两样？明年如果还是找不到男朋友，以后你就别来了……门吱呀一声开了，小卉一只手把着门边儿，半个脑袋探出来，满脸抑制不住的慌张，她撇着嘴问：真的？卷卷的头发微微颤，这副委屈紧张的小模样，像极了一只即将被遗弃的波斯猫。干吗？这是要哭吗？我一掌推在她脑门上，把她给推了回去。假的！赶紧做你的饭去吧。 想了想，又隔着门叫：你那爪子是金子打的吗？做饭还戴手套，你不怕焐出脚气来吗？菜板响，她躲在里面又在假装听不见。我溜达回包饺子的人群中间，冲小厨子使个眼色，可以行动了，开始包饺子吧。 小卉的生日计划是只双响炮二踢脚，引信被包进了饺子里。年夜饭开动前，我端起酒杯站起身发言：看到大家身心健康地又活了一年，我很欣慰……众人笑，集体说：呸！我正色道：今天在座的，有新人有老人，大都是没有家的人，此时此刻却又仿如一家人，we are family（我们是一家人）……为了欢迎新的族人家人，从今年起，我们定一个新规矩，每年选一个人当吉祥物，跨年钟声敲响之前，所有人都要作死地爱他，作死地宠他，送给他一吨惊喜。生命本没意义，有了爱才有意义，如果爱意有分量，咱们给他1000公斤。 戳起一个饺子，我说：谁吃到，谁就是吉祥物！饺子里藏了一个硬币，每个人都只许吃自己面前那份饺子……话音未落，桌上的饺子少了三分之一。一半夹在筷子上，一夹就是两个三个，一半塞进或大或小的嘴里，见过猴子的颊囊没？一模一样……身为庄家，自然讲究风度，我耐心地给予他们鼓励：慢慢吃别噎死……不许上手抓！ 有人一边狼吞虎咽一边问小卉，卉姑娘，你怎么吃着吃着不吃了？你不吃我可吃了哈。面前的盘子被拖走，瞬间一扫而空，小卉向来好脾气，任由掳掠完全不生气。她胳膊擎在半空，筷子头含在嘴里，眼神发直，怔怔地蠕动着嘴唇……半晌，唇一启，一枚硬币滴溜溜落地。 6小卉那天脖子上挂满了护身符，全是大家送的，十字架叠着玉观音，还有包银狼牙。大家宠死她了，抢着爱她，筷子分分钟被夺走，每一口菜都有人喂，还有人负责在一旁帮忙擦嘴，吃一口擦一下。我说行了，擦红了都，快擦秃噜皮了都。还有人掐住她的肩膀帮她做马杀鸡，唉，还让不让人家孩子吃东西了？还有人端来一锅热水非要帮她做足疗…… 我把那人打得满屋子跑，你家吃饭时洗脚啊？你家洗脚用锅啊？打死你！ 有人嘴笨，品性也憨纯，不懂如何献殷勤，只会左一句右一句夸人：小卉你特别好……小卉你不是一般的好，真的，非常好……翻来覆去就这么几句，语气诚恳得让人浑身起疙瘩，头皮麻酥酥。 小卉早傻了，任人摆布，话也不会说了，只会啊啊啊。最后一声“啊”凝固在嗓子眼儿里——巨大的一座笼屉在她面前掀开，猪头那么肥硕的一尊馒头出现在眼前。馒头当然不是猪头造型的，是蛋糕形的，三层。 我亮出菜刀……递过去。卉，来，你是吉祥物你来剪彩，过年讨个好彩头，切开切开。且慢，把灯先关了，所有人把身上的一次性打火机掏出来，一起点燃再一起吹灭，一起给小卉许个愿。小卉小卉，你愣着干吗？赶紧也给自己许个生……盛大的新年心愿。 小卉双手合十贴在额头，一闭眼，扑簌两颗泪滴下来。众人的愿望许了好久，一次性火机都快烫化了才重新睁开眼，火苗吹灭，欢呼声响起，此时当有音乐。我抬手双击掌，小厨子抱着吉他蹦出来，他紧张得脸都紫了，手一哆嗦，第一个和弦就摁错了。错了就按错的弹，小厨子像抱机关枪一样抱着吉他，扣扳机一样抠着琴弦，他抖着嗓子唱： ……这个新年让我想起，一个很久以前的朋友那是一个寒冷的冬天，他流浪在街头我以为他要祈求什么，他却总是摇摇头他说今天好像过年了，却没人祝他新年快乐新年快乐，祝你新年快乐，有生的日子天天快乐，别在意新年怎么过…… 原曲是郑智化版本的《生日快乐歌》，我改了词，把生日快乐改成了新年快乐。小厨子说得对，小卉隐瞒自己的生日一定别有隐情，就不要让她不自在了。 不自在的是小厨子，他太紧张了，最后的副歌到底还是颠颠倒倒唱成了原版，他唱：……生日快乐，祝你生日快乐，有生的日子天天快乐，别在意新年怎么过。 声音越唱越大，他看的是小卉姑娘的方向，唱得无比难听，却无比动情。有那么一刹那，我几乎确定他是故意这么唱的。好了，知道你是情不自禁，但众人若是疑惑起来，又该如何帮小卉圆场呢？ 没人疑惑。一曲唱完，整个屋子静了，门外鞭炮声此起彼伏，屋子里的人纷纷抹起了眼泪，终于有绷不住的姑娘哭出声来，哭的人越来越多，有人边哭边哼着歌，低声的吟唱渐渐变成了大合唱，他们唱：……有生的日子天天快乐，别在意新年怎么过。合唱终于变成了齐声喊：有生的日子天天快乐，别在意新年怎么过！ 无家可归的孩子们齐声喊：要过就好好过！神奇的小卉！把大馒头切开分了吧！ 小卉是愣着的，众人一起哭一起唱一起喊的时候，她都是愣着的，溪水一般的两道泪痕干在脸上，她隔着半个屋子，愣愣地看着小厨子。从小厨子一开始张嘴唱那首歌，她就已经愣了。 小卉呆呆地捉起菜刀，剁开馒头前，她向着小厨子的方向最后看了一眼。双唇轻启，她好像说了一声：谢谢…… 7我和小厨子蹲在小屋门口，我递给他一支烟。他说他不会抽烟，我说：你这辈子不缺人教你学好，总要有人教你学点儿坏。 他第一口就呛着了，不停地咳嗽，像反复上线的QQ一样。我拍他的背，我说：……你俩那天对视了起码有五分钟。他慌忙解释：当时之所以失态，是因为除夕那天我我我我……他又被那个难言之隐卡住了，唉，结结巴巴的，愁死人了。 我说：我什么我！小兄弟你知道吗，如果一个女的肯和你对视15秒以上，就意味着她对你也有好感。 他差点儿没呛死过去，一边疯狂咳嗽，一边不停地摇头。好半天，咳嗽终于止住了，头垂在膝盖中间，他闷声闷气地说：叔你别操心了，不可能的……我不过是个穷小子，别人会笑话的。 把头给我抬起来！是的没错，这个世界上看你笑话的人永远比在乎你的人多，世人皆是活在旁人嘴皮子底下的。但你听说过三大神回复没？句句都是真谛：1. 关你屁事！2. 关我屁事！3. 你懂个屁！ 他嗫嚅地说：可是，我只是个厨子哦，以后也不会有多大出息的。屁！如果法律规定只让有出息的人谈恋爱，中国早他妈不用计划生育了！ 小厨子，其实我明白你的意思。这是个阶级固化的时代，底层年轻人难以找到上行通道，大部分耗尽整个青春，追求的不过是生存，小部分解决了基本的温饱体面，却也不得不被“安全感”三个字套上缰绳，劳碌奔波。机会是有的，却是少的，忽悠是有的，却大多不过望梅止渴…… 但是孩子你听我说：资源和资源配置权的匮乏并不意味着一个人的情感追求也必须匮乏，换言之，你有没有出息和你配不配拥有爱情，蛋关系没有。 再者说，起点并不决定终点，出身并不决定金身，一辈子这么长，再平庸的人也会遭遇不平凡的人生际遇，你怎么知道你就一定没出息？再者说，小卉这么没毛病的女孩子，你觉得她选择对象会那么世故俗气吗？或许你所顾虑的人家完全不在乎呢？再者说，既然有“霸道总裁爱上我”，为什么不能有“神秘白富美接受我”？梦都不敢做，命还活什么活？ 小厨子琢磨了半天，头抬起一点儿来，瞟了我一眼。他说：叔，你说小卉姑娘对我也有好感……可她为啥后来没再搭理过我，看也不看我，一句话也没和我说。 就冲着这一句话，我就知你还是个处男，零经验，傻得像块木头一样。有哪个女神会主动？女神有那么好追吗？尤其是像你这种情况的屌丝逆袭。不看你就对了，如果坦坦荡荡地看你，反而证明你没戏懂不懂？她眼里不看心里在看懂不懂？这种情况下你不主动，还指望人家小姑娘主动吗？听好了！任何情况下都别指望女生对你主动，高级灵长类动物的生物本能决定了雌性生物的矜持本性，漫长的史前岁月里，雌性动物选择配偶时，矜持是淘汰弱者怂货的不二法宝，只有那些强悍自信、敢打能杀会觅食，同时擅长啪啪啪的雄性，才能获得最优先的生殖交配权。从生物学角度来讲，生命的意义不过是传递基因信息…… 小厨子打断我的话头，脸都白了：我没想交配……我鼻子都气歪了：我他妈说的也不是交配……处男真可恨！蠢死你吧纯死你吧……我又不是没当过处男，你再说一遍你没想过交配试试，蒙谁啊你？你敢说你一丁点儿都没想过吗？你说啊你说啊你…… 他哀求：叔你闭上嘴行吗？能不能别老说什么……配？我说好，不说配，说追。先把你和小卉两个人配不配这个问题丢一边儿，咱们探讨一下你该怎么去追，以及你该如何积极有效地去经营你的爱情。…………算了，别探讨了，自己悟去吧。可以经营的爱情，也就已经不能叫作爱情了。可以说得清的，都不叫爱。 烟掐了，别抽了。 8那个春节过得飞快，眨眼间人群散去，鸟儿们纷纷振翅，继续他们各自的远航。 临别前没有拥抱也没有送行。走了就走了咱都别矫情，有缘就明年再聚，缘尽就相忘于江湖。只要小屋不死，你就永远有地方过年。如果找到了另一半，记得除夕那天一起带回来，如果修成了正果，终于拥有了栖息地，那这块礁石也就不必再重返。各位保重，各自珍重。 小卉走得很晚，很罕见，她这次几乎拖到了公共假期的最后一天。端倪很明显，那么多天，小厨子在她左近晃来晃去，她看也不看一眼。小厨子离她越近耳朵越红，她却面色如常没什么反应，细心的我却发现，每当小厨子靠近，她的呼吸就会变得很轻，越近越轻，有时几乎暂停。眼睛却绝对瞟都不瞟一下的。 身为一个过来人，我深知拔苗助长有多害人，这么微妙的因缘种子，外人就别掺和了，是枯是荣，让它自己生自己长吧。 话虽这么说，终究还是没忍住。神奇的小卉辞行前，我忍不住点了她一句：除夕那天的大馒头，你知道是谁做的吗？她的呼吸一下子变得很轻很轻，良久，点点头。我笑：怎么样，对他有好感吗？小卉的呼吸轻得几乎暂停，不点头也不摇头，良久良久。 出租车的喇叭嘀嘀地催，天色不早了，该上路了。我拍拍小卉的脑袋，说：不如你把联系方式留下，我替你转交给他，你们可以先互相了解一下，切磋一下厨艺什么的，从朋友做起嘛……她一秒钟都没犹豫，拨浪鼓一样地摇头。哎呀我去，怎么眼眶又红了？女人啊真是搞不懂。 小卉走之前只问了一句：明年除夕我可以再来吗？我反问她：联系方式可以留给他吗？ 两只手套紧紧地攥在一起，她把嘴唇快咬出血来了，年纪轻轻，哪儿来那么多纠结顾虑？到底在为难什么？好了好了好了，不许哭，你可是神奇的小卉姑娘呀，别为难了，快走吧。我把她的肩膀扳向车门的方向，背后轻轻推了一下：保重，再见。 ……小厨子背着硕大的行囊，呆呆地走过来。他蹲下，坐到我身旁：叔，接下来我该怎么办？日光正好，春天里的五一街弥漫着三角梅的芳香，我摇摇头说：我也不知道。……他把手伸过来：给我一支烟。我摸兜，掏烟，把烟递给他，替他点上，再反手一巴掌把烟打掉！ 神奇又怎样，神秘又怎样，白富美又怎样？世间哪儿来那么多重逢？擦肩而过往往就是永远错过。还等什么？追啊，追不上也要追，真要有心的话，天涯海角也能找到她。 指着车开走的方向，我冲小厨子喊：跑！ 9我并未料到这个故事的走向，会忽然急转弯。就像我完全没有意料到，从小厨子那天狂奔到他再度忽然出现，只隔了短短几个月。 夏初的时候，他一屁股坐到我身边。没等我惊讶地叫出来，他摸出一盒烟，帮我点上一根，自己点上一根。居然没被呛着？短短几个月的时间，抽烟的姿势怎么忽然变得这么老练？没等我抬手打落那一明一暗的一点红，他先开口了。小厨子说：我找到小卉了。他说：答应我，听完了小卉的故事之后不要讨厌她。 他说：我终于找到小卉的那天，她正从一辆三轮车上往下卸货，整整一车的面粉，她一个人卸下来的…… ……小卉是化名。没有什么白富美，也不存在什么家族企业。小卉从事的确实是餐饮行业——她在学校食堂里卖饭，也做饭。 小卉生活在北方的一座老城。食堂的工资微薄，好在她不需要租房，住的是宿舍。她攒工资，足足攒上一年，攒够一笔盘缠、几身衣裳，供她去一趟远方。不是旅行，只是去过几天有家的日子。她是孤儿，没有过生日，没有过家，独自一人长大。 这个年纪的女孩总是对生活充满了期待和想象，越是漂亮的女孩，越有无限的可能性在面前绽开。小卉例外，她每年最大的期待，不过是一个除夕。一整年的准备和等待，只为换来除夕的那一场团聚。温暖的，奇幻的，童话一样的。 每年攒下的钱就那么点儿，必须精打细算着花。衣服是一件一件攒的，鞋子也是，都是反季打折时网购的。要攒，也要藏，有些东西必须藏好，不然她攒够了衣裳，也攒不够踏上这段旅程的心力。手套是必须戴的，为了掩盖切菜留下的刀痕、热油烫出的疤，以及掌心那层怎么也搓洗不掉的茧子。一双一双地攒手套，一样一样地攒口红眉笔，她躲在幽暗的宿舍里，比着杂志学化妆，上百次的摸索，描摹出梦想中的自己。 哪个女孩没做过公主梦？但从小到大，从没人给她买过洋娃娃。她每年出发之前去一次美容工作室，狠狠心花掉几百元钱，烫一次洋气的小波浪卷头发，洋娃娃一样，换了一个人一样。……自信像一串珠链，零零星星拼凑，一粒一粒地串起。她绞尽脑汁把卑微的自己掩藏，再怯怯地，把梦想中的自己展示给那个临时家庭。 大家都爱她，夸她神奇，一切美好得像场梦，她也深爱着梦中的自己。心里面其实是明白的：她每年只有这一次机会被所有人喜欢，每次只有一个多星期。 是美梦总会担心醒，就像童话里写的那样，当午夜12点的钟声响起，马车变回南瓜，白色晚礼服变成灰衣麻布裙，所有的魔法都会消失。只有悉心隐藏，才有机会企盼下一年的梦境，短暂的欢愉后，她必须悄无声息地离去，不能留下任何联系方式。 小卉是化名。卉姑娘，本就是灰姑娘的谐音。 10无语了很久，直到烟灰刺啦烫了手。一直以为她是个白富美，原来全都是骗人的。卉姑娘算是在撒谎吗？细想想，关于身世和经济状况，她只字未提，给人留下的只是一个误会的印象而已。真是个孩子，何必这么做呢？ 我说：这个傻姑娘……为什么不用真面目示人呢？难道在小屋里还会有人笑话她不成？小厨子说：叔，你开始有点儿讨厌她了吗？你会觉得她虚荣吗？我噎住了，不知怎么回答他。 ……小厨子在小卉所在的城市停下，他找了一份临时工作，小饭馆里当面案厨师，一待就是几个月。饭馆离学校不算远，小厨子每天都会去那个食堂，偷偷地看她一会儿。看她扛米背面，看她站在窗口卖饭，窗口外都是她的同龄人，薄薄几条不锈钢栏杆，里外两重天。小厨子看着她被同事讥讽，他们阴阳怪气地说：看这头发烫的，咱们食堂还出了个平面模特呢……模特，今天没去取快递吗？最近没买名牌大衣吗？又挤眉弄眼地说：其实那些衣服都是别人送的吧？唉，那么有钱，怎么还舍得让你在这里吃油烟？小卉姑娘不言不语，看来早已经习惯了这样的奚落。她唯一的应对方式是不停干活，仿佛忙碌起来以后，所有的杂音就全都听不见。……小厨子说，干活时的小卉素面朝天，并没有除夕时好看，说实话，丢到人群中绝对不起眼的那种普通……唯一扎眼的是她那一双手，通红的，皱皱巴巴的，隔着很远都看得见。 他看着她一个人卸货，又一个人蹬着车子去进货，一个人做贼一样地取快递，一个人收工回宿舍，肥大的工作服在身上晃荡，快递包裹抱在怀里，她走路时是低着头的。他说他越看越心疼，每天都要拼命抑制住想要上前喊她的冲动。喊了又能怎样？他并不知道该对她说些什么。 冥冥之中似乎有一种促狭的力量，总在暗暗把人的命运操控：想要的得不到，喜欢的都失去，得到的都不过如此，而越是小心翼翼捧着的，越要帮你打翻在地……小厨子没去打扰卉姑娘的生活，但事情终究还是打翻了一地。 小厨子打工的小饭馆卖北方面食，那天他把笼屉端到门口的柜台，盖子刚一掀开，就有路人被吸引了过来，那人问：老板，馒头怎么卖？隔着升腾的白雾，他看到小卉扶着三轮车站在面前。小卉的脸色一开始是平静的，随着雾气的散尽，骤然变得煞白。 短短的几秒钟后，小卉转过身去，扶着车子走开。他冲出店门去追她，笼屉猛地被撞翻，雪白的馒头滚落一地，瞬间沾满泥沙尘垢。他想喊她，脑子里却一片空白，什么都喊不出来。 小卉没回头，脚步也没停，一声声喇叭响起，她却什么也听不见。她推着车子，径直走在晚春的街头。车流里逆行，渐行渐远。 ……故事悄悄地结束了，仿佛从未发生过。 11神奇的卉姑娘，我知道你一定会读到这篇文章。其实没人有资格谴责你什么，也没人有权利阻止你去制造那些美好的假象。你的谎言，其实往往就是你的梦想。其实我们每个人都一样。 我只是很想问问你：如果故事可以重写，你会给它安上怎样的一个结局？ 假设把小饭馆前的四目相对，换到下一个除夕，你是否还会转身就走？假设那天身份没有被识破，下一个除夕时，你是否会和小厨子在一起？假设一切都能晚一点儿再发生，事情是否会有所改变？假设那天逆行的车流中，他能大胆一点儿追上你，你是否会允许这个笨拙的孩子，笨拙地爱你？ OK，所有的假设都是狗屁，都无法更改业已成型的现实。所以我们说人生如梦，醒了就回不去。 卉姑娘。我曾一度认为你和小厨子之间是一个奇幻的开始，管他是富是穷，总会打破固有的人物设定。但我忘了所有童话的结局都不曾在现实世界里完美复制，非虚构的爱情终究逃不开命运规律。奇迹没有发生，小厨子并没有变身成小王子。灰姑娘推着三轮车，并没有坐在南瓜马车里。曾经在除夕夜里四目相对的孩子，终究擦肩而过，相顾无语。………… 好了，该回顾的已回顾完毕，无须赘述，再矫情是放狗屁。我写下这个故事的目的，只是在履行对一个人的承诺。同时，我希望你能知晓他真实的心意，以及他最初关注你的真实原因。 卉姑娘。那天讲完了你的身世和你的背影后，小厨子说出了他来找我的目的，他说：小卉每年只有一个星期的时间，成为她梦想中的自己，不要着急揭穿她，无论如何，帮她把梦继续做下去吧。 我问：这个“她”是哪一个，是戴上手套的那个还是摘下手套的那个？小厨子，你心里装着的灰姑娘是哪一个？他回答说，在他心里小卉只有一个。他说：……除夕夜里，躲在屋檐角落里，边哭边给自己小声唱生日歌的那个。 明白了，我该怎么做？他说：叔，你可不可以假装什么都不知道，可不可以每年除夕都帮小卉过一次生日？ 122014年除夕。遵循小厨子的嘱托，我准备好了三种不同的生日方案。可是小卉，你并没有出现。 2015年除夕。小卉，你还是没有出现。 又是一年除夕尽，现在是2016年2月10日，正月初三。德雷克海峡风速30节，浪高9米，穿越这片沉船无数的海域，前方就是南极了。整整四天远离人间，我无法获悉小屋今年的除夕夜，都有哪些单飞的鸟儿停歇。 姑娘你今年来了吗？一个人来的吗，还是两个人来的？戴着手套来的，还是摘了手套来的？饺子里的硬币每年都包，今年的硬币你吃到了吗？合唱每年都有，有没有和大家一起合唱那首《新年快乐歌》？其实是《生日快乐歌》，你懂的。 好吧，或许今年的除夕你依旧没有出现。那你明年会来吗？ 船在颠簸，起起伏伏的冰山在不远处漂过。此刻我坐在船尾甲板处，在风浪里写下上述文字，快结尾了，这个不知该如何画上句号的故事。 除夕夜里的团圆饭，你缺席了两年。小厨子也缺席了两年。灰姑娘或许还会再度出现，而小厨子或许永远不会再来。 三年前，小厨子说：都怪我太笨，我搞砸了……不要揭穿她，帮她把梦继续做下去吧。他说：叔，你可不可以假装什么都不知道，可不可以每年除夕都帮小卉过一次生日？ 他说他下一个除夕可以不来，如果需要，他可以永远都不再出现。他说他不想因为自己的出现，让你再度难堪地逃开。他也是个无家可归的孩子，他一直是个笨拙的孩子，笨拙地护持着你的梦，希望你把梦做完。 我问他：不遗憾吗？自始至终你们只有过两次对视，连一句完整的对白都没说过。他说：你忘了吗？我还给她唱过一首《生日快乐歌》。 我拦住他问：小厨子你想过没有，你对小卉的感情，到底是心疼还是爱？他反问我：有区别吗？叔你不是说过吗，能说得清楚的，都不叫爱。他说，这种说不清楚的感觉，从发现小卉生日那一刻就开始了…… 小厨子走了。我再没见过他。也不知道孤身一人的他，后来去哪里过的除夕，有没有吃上饺子。 13看得懂的，都不是命运。说得清的，都不叫爱情。忘得了的，都不是遗憾。听得见的，都不是伤心。躲得开的，都不是缘分。猜得透的，都不叫人生。 这篇文章是一个寻人启事。寻的是一个故事的结尾，找的是两个离家太久的孩子。 卉姑娘，故事该怎样画上句号，自己决定吧。 若你愿意继续当你的灰姑娘，有一间小屋永远乐意当你的南瓜马车。如果你希望这个故事悄悄地结束，仿佛从未发生过。那么好吧，保重，祝你生日快乐。 另外，有个片段想和你分享。就当作赠你的生日礼物吧。 那年除夕夜里，烟花开满天际。你躲进人群背后的屋檐角落，边哭边给自己小声唱歌。不远处，有个男生默默看着你，只有他清楚你在唱什么。只有他一个人发觉了你悄声唱着的，是《生日快乐歌》。……那天也是他的生日。他低声哼着的，是同一首歌。]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[年轻人，吃亏要趁早]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E5%B9%B4%E8%BD%BB%E4%BA%BA%EF%BC%8C%E5%90%83%E4%BA%8F%E8%A6%81%E8%B6%81%E6%97%A9%2F</url>
    <content type="text"><![CDATA[张爱玲说，出名要趁早，来得太晚的话，快乐也不那么痛快。其实，吃亏也要趁早，别等到太晚，连重来的机会都没有。1昨天和朋友聊到很晚，在彼此都很忙碌的时候，能够在夜深人静时，用最简单的言语，隔着遥远的距离，依然让人舒心。但朋友最近好像过的并不舒坦，电话中，道述着遇到的烦心事。本科毕业，朋友进了一家设计公司，因为涉世不深，带着一身稚气的他碰了一鼻子的灰。工作不像学习，公司也不是学校，很多为人处事的方式都需要改变，一个不小心就会踩到禁区。虽然开始很艰难，但朋友一直都勤恳学习着，一些小的挫折和委屈，都咬咬牙坚持着，可最近的一件事，却碰到了他的底线，整个人彻底爆发了。因为最近有个公司要和他们合作，让他们帮忙设计一个产品的推广广告，项目不小，利润挺高，于是他们的经理便动员大家展开头脑风暴，寻求最有创意和效果的方案。说真的，虽然朋友资历不是很高，但他确实在这一块有很高的天赋和敏感度。他一听完经理的介绍，便在心中有了一个构思蓝图，但又觉得自己想法太粗糙，便向公司的一位前辈求教取经。很多时候，年轻的我们总是以为人和人之间就像双眼所见的那么简单，其实，在我们看不见的背后，那些复杂和丑陋，会让我们难以置信。2昨天经理召集朋友他们开会，说有位同事交上了很有创意和想法的方案，让大家一起参考和提提意见。当经理打开PPT展示，朋友一下子就懵逼了，这个创意怎么和自己的那么相似？各种疑惑和猜疑，在经理喊出提交方案的同事名字时，便豁然开朗。这不是自己请教和交流的前辈么，朋友还记得这位前辈夸他有天赋，鼓励他继续加油，怎么转眼间，就成了他的方案了呢？朋友知道自己被这位前辈欺骗了，等到会议结束，便去找他交谈，想问问到底是怎么回事，但却被他一句，这是我想的方案，你说是你的，有什么证据么？气不过的朋友找到了经理，说了自己情况，但经理也只有一句，小付继续加油吧，以后的机会还很多，便不了了之。这么多年来，朋友一直过的顺风顺水，没遇到过什么大挫折，也没有受到什么大打击，在他的印象里，事业的路途中，大家应该是各凭本事争取着，怎么会有人拿着别人的成果包装成自己的作品？朋友知道这次项目挺重要的，好的方案如果被启用，肯定会有不小的奖励，但他真的不是在意奖励的多少，他气愤的是最基本的信任都被别人摧残的支离破碎。后来，朋友在电话里说，他真的太年轻了，想法和经验都没跟上社会的节拍，这次的事件让他成长了很多，他相信未来肯定不止这一次的意外，他吃亏了一次，下一次就没那么蠢了。言语间，说不出的无奈和沉重。谁都想简单快乐地去生活和工作，可事与愿违的太多，有些事情经历过才能成长，代价也许很大，但这是我们前进道路上，不得不交的学费。3吃亏还是要趁早，至少年轻的我们还有继续走下去的勇气和决心，痛苦和委屈都会过去，时间会沉淀所有。我至今还记的高中的一个同学，因为经常坐最后几排，彼此关系也不错。他家原本是挺殷实的，他老爸经常在外跑生意，赚了不少钱，所以那时候他经常请我们周末出去吃饭。可在高二下学期的时候，他突然休学了，各种方式都联系不到他，于是我们几个关系好的，便跑到班主任那里问问情况。却得到了，他父亲跳楼自杀，他选择了休学这样一个回答。当时年幼的我们，还不太明白其中的意义，只知道同学他以后没有父亲，也不再来上学了，不是很懂事的我们，但心里依然疼的难受。后来，我们看到同学的母亲来学校帮他办退学手续，以前那个美丽的阿姨，没有了昔日的容颜，憔悴的脸庞，蓬乱的头发，眼睛里道不出的沧桑。我们上前问她同学的情况，她对我们说，她们要搬家了，不在这里生活了，要回她的娘家去了，同学也跟着她回去，不再这边上学了。就这样，同学和我们彻底失去了联系。随着时间的推移，从别人口中的只言片语中，才知道，原来同学的父亲和一个韩国人合办了公司，把自己的钱都投进去了，还欠了一大屁股的债，后来这个韩国人跑路了，公司也倒闭了，债主堵着他家门口要债，受不了压力的他，选择了跳楼自杀。无限唏嘘，曾经我们是那么羡慕着同学，说他有个好爸爸，给他那么多零花钱，买我们只能从电视里看到的球鞋，他也曾说过，他父亲这些年在外跑生意，每年都会赚不少钱，一路平坦顺风，没遇到什么大意外。没吃过亏，一帆风顺也不见得完全是件好事，因为温室里的花草太娇嫩，一见风雨便承受不住。4年轻的我们，需要努力，需要拼搏，为着自己的梦想不断前行，一路上我们收获喜悦悲伤，但这些都是经历和成长，是我们最宝贵的财富。很多时候，身边的人总在抱怨昨天被什么坑了，今天又被哪个骗了，无止尽的谩骂。其实真的不必如此动怒，你吃过的这些亏，不外乎因为自己太年轻，少不更事，容易掉进别人的圈套里，但这又何妨？这些正是年轻的你该经历的事情罢了，傻过蠢过，青春就过去了。只有亲身经历，才能让记忆深刻，让身体记住那瞬间的感受，多痛苦，多难过，都没关系，一切都会过去，但希望的是，这些你吃过的亏，能够让你成长，一次经历，一生难忘，不要只知道谩骂世道的悲凉，不长记性的你，就成了真正的蠢蛋了。希望你们在世间的行走中，练就一身铠甲，等到年迈沧桑，看到一切事情都风轻云淡，品一口香茗，缓缓说道，没什么大不了的，这都是小事。本文来自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我想和你虚度时光]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E6%88%91%E6%83%B3%E5%92%8C%E4%BD%A0%E8%99%9A%E5%BA%A6%E6%97%B6%E5%85%89%2F</url>
    <content type="text"><![CDATA[我想和你虚度时光，比如低头看鱼比如把茶杯留在桌子上，离开浪费它们好看的阴影我还想连落日一起浪费，比如散步一直消磨到星光满天我还要浪费风起的时候坐在走廊发呆，直到你眼中乌云全部被吹到窗外我已经虚度了世界，它经过我疲倦，又像从未被爱过但是明天我还要这样，虚度满目的花草，生活应该像它们一样美好一样无意义，像被虚度的电影那些绝望的爱和赴死为我们带来短暂的沉默我想和你互相浪费一起虚度短的沉默，长的无意义一起消磨精致而苍老的宇宙比如靠在栏杆上，低头看水的镜子直到所有被虚度的事物在我们身后，长出薄薄的翅膀我想和你虚度时光…… 本文来自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我连我们80岁的样子都想好了，我们还是分手了]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E6%88%91%E8%BF%9E%E6%88%91%E4%BB%AC80%E5%B2%81%E7%9A%84%E6%A0%B7%E5%AD%90%E9%83%BD%E6%83%B3%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E5%88%86%E6%89%8B%E4%BA%86%2F</url>
    <content type="text"><![CDATA[不知道为什么，在一起的每一对情侣，都喜欢憧憬以后的生活。好像未来的生活场景说得越详细，就越容易发生。事实上，不论你精确到哪一分哪一秒，分开往往比未来先来。 后台收到一条留言。妹子说，“我连我们80岁的样子都想好了，我们还是分手了”。与人分别，最大的痛苦或许是，原本计划要两个人一起做的事情，最后都不得不自己完成。甚至很多人都没有勇气再去完成那些事情。 他说你养一条狗，他养一只猫，一猫一狗，他和你，就是生活幸福的样子。于是你开始想，狗和猫在一旁玩时，你们还在一起打打闹闹。你会想到他宠溺动物的样子，然后自己笑出声来。那场景真实得，你想马上开始那样的生活。他说，很多事我们不用急着现在做，来日方长。于是你似乎就信了，你相信你们还有很多日子可以一起过。很多事就拖着拖着，到最后你们分开了，没做的事就成了遗憾。你终于知道，来日太长，你们已经不在彼此身旁。 人的想象能力太强了，所以当期待不能成为现实时，就变成了悲哀。他说想和你上床，你就在心里铺好了床。他说等以后，你就以为真的有以后。明知道爱情并不牢靠，却还是陷进去不肯回头。其实只要清醒一点点，你就知道，现在比未来真实得多。 有人跟我说，我谈恋爱，只说现在不谈以后。也不知道这是算幸运还是悲哀。幸运的是，他不让你有幻想，这样就不容易太失望。悲哀的是，一个人不想和你聊以后，是不是他压根儿就没有把你放在心上，不想和你有以后。 要认清现实是真的，要憧憬以后也是正常的。爱得太深的那个连80岁的样子都想好了，爱得清醒那个端酒碰杯，祝祖国河山，不祝我们。 爱情里的事，不要想得太远了。没有什么事是可以一步登天的，每一步都走得很踏实的话，未来是顺其自然而来的。有一句话说，期望越大，失望就会越大。期望越大的事，来了便罢，如果是没有来呢，你不知道会多难过。若是没有太大期望的事，不来就算了，来了又何尝不是莫大的惊喜呢。你说是吧。 如果可以的话，就一步一步走。至于往后是互相陪伴还是各自天涯，让未来顺其自然而来吧。 晚安，想梦见你。本文来自互联网]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[是不是一个人太久了，总觉得时间在翻倍的过。我不知道自己在找什么，只觉得丢了很多…………]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BA%BA%E5%A4%AA%E4%B9%85%E4%BA%86%EF%BC%8C%E6%80%BB%E8%A7%89%E5%BE%97%E6%97%B6%E9%97%B4%E5%9C%A8%E7%BF%BB%E5%80%8D%E7%9A%84%E8%BF%87%E3%80%82%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E5%9C%A8%E6%89%BE%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8F%AA%E8%A7%89%E5%BE%97%E4%B8%A2%E4%BA%86%E5%BE%88%E5%A4%9A%E2%80%A6%E2%80%A6%E2%80%A6%E2%80%A6%2F</url>
    <content type="text"><![CDATA[是不是一个人太久了，总觉得时间在翻倍的过。我不知道自己在找什么，只觉得丢了很多…………]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给自己一段去拼的时光，愿父母能等的起我]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%9C%89%E6%AF%92%E7%9A%84%E6%96%87%E5%AD%97%2F%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%80%E6%AE%B5%E5%8E%BB%E6%8B%BC%E7%9A%84%E6%97%B6%E5%85%89%EF%BC%8C%E6%84%BF%E7%88%B6%E6%AF%8D%E8%83%BD%E7%AD%89%E7%9A%84%E8%B5%B7%E6%88%91%2F</url>
    <content type="text"><![CDATA[所谓的成长22岁的自己，经历了人生的苦难，亲人的离去，父母的苍老，初恋的美好，我觉得自己算得上是长大了。是时候去过自己想要的生活了。 是时候执着一次，专注的去争取自己想要的生活了，是该长大，抛弃曾经的幼稚的想法。 追逐的梦想他们说，当你的能力还不足以撑起你的野心的时候，就静下心来学习。鹰不能搏击长空的时候就静等羽翼丰满吧，要相信这个世界上真的有人过着你想要的生活。 我说，将来的你也不一定感谢现在拼命的自己，但是我想只要在将来功成名就了的某个闲暇的午后，品一杯暖茶的同时回忆曾经那个拼命的自己，能感动自己就足够了。不求轰轰雷烈，但求感动自己，对得起你爱的人！ 很多很浅显的道理，我却用了三年来懂得。大概这就是成熟了吧，可是我向来知道——成熟懂事从来都不是褒义词。 成熟？呵呵，只要人没死，就一直在长大的路上 回顾三年的大学时光，平凡的注定平凡，非凡的终了也归于了平凡。 命运总是曲折迷离……命运善嫉，总吝啬赋予世人恒久的平静，总猝不及防地把人一下子塞进过山车，任你怎么恐惧挣扎也不肯轻易停下来，非要把圆满的颠簸成支离破碎的，再命你耗尽半生去拼补…… 然后会想起高考结束时，老板的那句话：士不可以不弘毅，任重而道远！ 快乐吗马云说，梦想还是要有的，万一实现了呢？王健林说，可以先定一个小目标，比如赚他一个亿！大冰说，平行世界，多样生活，既可以朝九晚五，又能够浪迹天涯…… 于是你干了这碗心灵乌鸡汤，想尽办法的是自己忙碌起来，并谓之——充实！ 然而，快乐吗？问下你自己，你过的快乐吗？ 幼稚也是一种成长如今踏入工作岗位，步入社会，才懂得处世俗之中真的很难保持自我。 说过的“不以物喜，不以己悲”呢？读过要励志做到“居庙堂之高则忧其民 处江湖之远则忧其君”了吗？你还会告诉自己要多读书，将来“修身，齐家，治国，平天下”吗？幼稚，对吧！ 被房价打败了？被现实清洗了？ 终于认清自己是个“平凡的世界”中的一份子了吧。那么大的人了，你还有棱角吗…… 至少，我是。也许明白我是个平凡的人是件好事吧，那样就不会幻想去改变世界了。可是……到最后，我还是被这个世界给改变了…… So What! 至少我是向着好的方向变的，不迷失自我，改变了又能怎样! 90后的个尴尬的词，大部分的90后都是农村的吧，回不去的老家，留不下的北上广深。俗语说，君子 性非异也，善假于物也。我不是君子，但是我选择了这个时代算的上前沿的工具——互联网，我希望能凭自己三年来的积累和未来的努力给我爱的人一个比较好的生活环境。 我要的不多，爸妈，她，有个宝宝养只狗狗就是我想要的那个家。 就给自己一段时间来沉淀，羽翼丰满的那一天就去闯荡天涯，既是江湖人，又何必问你的过去，那就让我们用青春换未来吧！ 愿那些经历了爱情的磨难的人们，依然可以敢爱如那年，但已不匆匆。愿那些梦想破败过的人们，有梦为马，依然可以浪迹天涯。愿那些一直平平淡淡，什么都没遇到的人们，你们是幸福的，继续幸福下去吧。愿你一辈子也用不到“时间”和“新欢”来遗忘曾经的那断刻骨的时光！愿你，我和那个仍然努力却一无所有那个他，看尽这个世界的黑暗和暗淡后依然燃烧着内心善良而炽热的梦想，照亮前方！ 感谢你能百忙中听完我的胡言乱语，谢谢。愿你善良，成长。]]></content>
      <categories>
        <category>有毒的文字</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 实现我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849步骤 1创建中介类。ChatRoom.javaimport java.util.Date;public class ChatRoom &#123; public static void showMessage(User user, String message)&#123; System.out.println(new Date().toString() + &quot; [&quot; + user.getName() +&quot;] : &quot; + message); &#125;&#125;步骤 2创建 user 类。User.javapublic class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User(String name)&#123; this.name = name; &#125; public void sendMessage(String message)&#123; ChatRoom.showMessage(this,message); &#125;&#125;步骤 3使用 User 对象来显示他们之间的通信。MediatorPatternDemo.javapublic class MediatorPatternDemo &#123; public static void main(String[] args) &#123; User robert = new User(&quot;Robert&quot;); User john = new User(&quot;John&quot;); robert.sendMessage(&quot;Hi! John!&quot;); john.sendMessage(&quot;Hello! Robert!&quot;); &#125;&#125;步骤 4验证输出。Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John!Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert!]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111步骤 1创建一个接口。Shape.javapublic interface Shape &#123; void draw();&#125;步骤 2创建实现接口的实体类。Circle.javapublic class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println(&quot;Circle: Draw() [Color : &quot; + color +&quot;, x : &quot; + x +&quot;, y :&quot; + y +&quot;, radius :&quot; + radius); &#125;&#125;步骤 3创建一个工厂，生成基于给定信息的实体类的对象。ShapeFactory.javaimport java.util.HashMap;public class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap(); public static Shape getCircle(String color) &#123; Circle circle = (Circle)circleMap.get(color); if(circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println(&quot;Creating circle of color : &quot; + color); &#125; return circle; &#125;&#125;步骤 4使用该工厂，通过传递颜色信息来获取实体类的对象。FlyweightPatternDemo.javapublic class FlyweightPatternDemo &#123; private static final String colors[] = &#123; &quot;Red&quot;, &quot;Green&quot;, &quot;Blue&quot;, &quot;White&quot;, &quot;Black&quot; &#125;; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 );//这种获取随机数的方式，感觉小编没毕业呢吧？？？？//呵呵，我复制的懒得改，领悟党的精神算了 &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125;&#125;步骤 5验证输出。Creating circle of color : BlackCircle: Draw() [Color : Black, x : 36, y :71, radius :100Creating circle of color : GreenCircle: Draw() [Color : Green, x : 27, y :27, radius :100Creating circle of color : WhiteCircle: Draw() [Color : White, x : 64, y :10, radius :100Creating circle of color : RedCircle: Draw() [Color : Red, x : 15, y :44, radius :100Circle: Draw() [Color : Green, x : 19, y :10, radius :100Circle: Draw() [Color : Green, x : 94, y :32, radius :100Circle: Draw() [Color : White, x : 69, y :98, radius :100Creating circle of color : BlueCircle: Draw() [Color : Blue, x : 13, y :4, radius :100Circle: Draw() [Color : Green, x : 21, y :21, radius :100Circle: Draw() [Color : Blue, x : 55, y :86, radius :100Circle: Draw() [Color : White, x : 90, y :70, radius :100Circle: Draw() [Color : Green, x : 78, y :3, radius :100Circle: Draw() [Color : Green, x : 64, y :89, radius :100Circle: Draw() [Color : Blue, x : 3, y :91, radius :100Circle: Draw() [Color : Blue, x : 62, y :82, radius :100Circle: Draw() [Color : Green, x : 97, y :61, radius :100Circle: Draw() [Color : Green, x : 86, y :12, radius :100Circle: Draw() [Color : Green, x : 38, y :93, radius :100Circle: Draw() [Color : Red, x : 76, y :82, radius :100Circle: Draw() [Color : Blue, x : 95, y :82, radius :100]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是设计模式-提纲掣领]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8F%90%E7%BA%B2%E6%8E%A3%E9%A2%86%2F</url>
    <content type="text"><![CDATA[设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern）结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern）行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern）、设计模式间的关系 设计模式的六大原则 1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 实现我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566步骤 1创建一个接口。Image.javapublic interface Image &#123; void display();&#125;步骤 2创建实现接口的实体类。RealImage.javapublic class RealImage implements Image &#123; private String fileName; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println(&quot;Displaying &quot; + fileName); &#125; private void loadFromDisk(String fileName)&#123; System.out.println(&quot;Loading &quot; + fileName); &#125;&#125;ProxyImage.javapublic class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125;步骤 3当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。ProxyPatternDemo.javapublic class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(&quot;test_10mb.jpg&quot;); //图像将从磁盘加载 image.display(); System.out.println(&quot;&quot;); //图像将无法从磁盘加载 image.display(); &#125;&#125;步骤 4验证输出。Loading test_10mb.jpgDisplaying test_10mb.jpgDisplaying test_10mb.jpg]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模式定义单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 模式结构 12345678910111213141516171819202122232425262728293031323334353637383940步骤 1创建一个 Singleton 类。SingleObject.javapublic class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125;步骤 2从 singleton 类获取唯一的对象。SingletonPatternDemo.javapublic class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125;步骤 3验证输出。Hello World! 单例模式的几种实现方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091、懒汉式，线程不安全是否 Lazy 初始化：是是否多线程安全：否实现难度：易描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。代码实例：public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。2、懒汉式，线程安全是否 Lazy 初始化：是是否多线程安全：是实现难度：易描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。代码实例：public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。代码实例：public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起是否 Lazy 初始化：是是否多线程安全：是实现难度：较复杂描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。代码实例：public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、登记式/静态内部类是否 Lazy 初始化：是是否多线程安全：是实现难度：一般描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。代码实例：public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 6、枚举JDK 版本：JDK1.5 起是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。代码实例：public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。`]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型模型]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[定义原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 实现我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124步骤 1创建一个实现了 Clonable 接口的抽象类。Shape.javapublic abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125;步骤 2创建扩展了上面抽象类的实体类。Rectangle.javapublic class Rectangle extends Shape &#123; public Rectangle()&#123; type = &quot;Rectangle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;Square.javapublic class Square extends Shape &#123; public Square()&#123; type = &quot;Square&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;Circle.javapublic class Circle extends Shape &#123; public Circle()&#123; type = &quot;Circle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125;步骤 3创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。ShapeCache.javaimport java.util.Hashtable;public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId(&quot;1&quot;); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(&quot;2&quot;); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(&quot;3&quot;); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125;步骤 4PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。PrototypePatternDemo.javapublic class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;); System.out.println(&quot;Shape : &quot; + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;); System.out.println(&quot;Shape : &quot; + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;); System.out.println(&quot;Shape : &quot; + clonedShape3.getType()); &#125;&#125;步骤 5验证输出。Shape : CircleShape : SquareShape : Rectangle]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[参考资料-设计模式学习]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[设计模式java版https://gof.quanke.name/图说设计模式https://design-patterns.readthedocs.io/zh_CN/latest/index.html菜鸟教程设计模式http://www.runoob.com/design-pattern/singleton-pattern.html]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 实现我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990步骤 1创建一个命令接口。Order.javapublic interface Order &#123; void execute();&#125;步骤 2创建一个请求类。Stock.javapublic class Stock &#123; private String name = &quot;ABC&quot;; private int quantity = 10; public void buy()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, Quantity: &quot; + quantity +&quot; ] bought&quot;); &#125; public void sell()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, Quantity: &quot; + quantity +&quot; ] sold&quot;); &#125;&#125;步骤 3创建实现了 Order 接口的实体类。BuyStock.javapublic class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125;SellStock.javapublic class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.sell(); &#125;&#125;步骤 4创建命令调用类。Broker.javaimport java.util.ArrayList;import java.util.List; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125;步骤 5使用 Broker 类来接受并执行命令。CommandPatternDemo.javapublic class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); &#125;&#125;步骤 6验证输出。Stock [ Name: ABC, Quantity: 10 ] boughtStock [ Name: ABC, Quantity: 10 ] sold]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 实现备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879步骤 1创建 Memento 类。Memento.javapublic class Memento &#123; private String state; public Memento(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125; &#125;步骤 2创建 Originator 类。Originator.javapublic class Originator &#123; private String state; public void setState(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125; public Memento saveStateToMemento()&#123; return new Memento(state); &#125; public void getStateFromMemento(Memento Memento)&#123; state = Memento.getState(); &#125;&#125;步骤 3创建 CareTaker 类。CareTaker.javaimport java.util.ArrayList;import java.util.List;public class CareTaker &#123; private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); public void add(Memento state)&#123; mementoList.add(state); &#125; public Memento get(int index)&#123; return mementoList.get(index); &#125;&#125;步骤 4使用 CareTaker 和 Originator 对象。MementoPatternDemo.javapublic class MementoPatternDemo &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(&quot;State #1&quot;); originator.setState(&quot;State #2&quot;); careTaker.add(originator.saveStateToMemento()); originator.setState(&quot;State #3&quot;); careTaker.add(originator.saveStateToMemento()); originator.setState(&quot;State #4&quot;); System.out.println(&quot;Current State: &quot; + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(&quot;First saved State: &quot; + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(&quot;Second saved State: &quot; + originator.getState()); &#125;&#125;步骤 5验证输出。Current State: State #4First saved State: State #2Second saved State: State #3]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。```步骤 1创建一个接口。Shape.javapublic interface Shape { void draw();}步骤 2创建实现接口的实体类。Rectangle.javapublic class Rectangle implements Shape { @Override public void draw() { System.out.println(“Rectangle::draw()”); }}Square.javapublic class Square implements Shape { @Override public void draw() { System.out.println(“Square::draw()”); }}Circle.javapublic class Circle implements Shape { @Override public void draw() { System.out.println(“Circle::draw()”); }}步骤 3创建一个外观类。ShapeMaker.javapublic class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } public void drawCircle(){ circle.draw(); } public void drawRectangle(){ rectangle.draw(); } public void drawSquare(){ square.draw(); }}步骤 4使用该外观类画出各种类型的形状。FacadePatternDemo.javapublic class FacadePatternDemo { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); }}步骤 5验证输出。Circle::draw()Rectangle::draw()Square::draw()···]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384步骤 1创建一个接口。Shape.javapublic interface Shape &#123; void draw();&#125;步骤 2创建实现接口的实体类。Rectangle.javapublic class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;Square.javapublic class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;Circle.javapublic class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125;步骤 3创建一个工厂，生成基于给定信息的实体类的对象。ShapeFactory.javapublic class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125;&#125;步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。FactoryPatternDemo.javapublic class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125;步骤 5验证输出。Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 建造者模式包含如下角色：Builder：抽象建造者ConcreteBuilder：具体建造者Director：指挥者Product：产品角色 实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。 汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。 冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186步骤 1创建一个表示食物条目和食物包装的接口。Item.javapublic interface Item &#123; public String name(); public Packing packing(); public float price(); &#125;Packing.javapublic interface Packing &#123; public String pack();&#125;步骤 2创建实现 Packing 接口的实体类。Wrapper.javapublic class Wrapper implements Packing &#123; @Override public String pack() &#123; return &quot;Wrapper&quot;; &#125;&#125;Bottle.javapublic class Bottle implements Packing &#123; @Override public String pack() &#123; return &quot;Bottle&quot;; &#125;&#125;步骤 3创建实现 Item 接口的抽象类，该类提供了默认的功能。Burger.javapublic abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125;ColdDrink.javapublic abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125;步骤 4创建扩展了 Burger 和 ColdDrink 的实体类。VegBurger.javapublic class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return &quot;Veg Burger&quot;; &#125;&#125;ChickenBurger.javapublic class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return &quot;Chicken Burger&quot;; &#125;&#125;Coke.javapublic class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return &quot;Coke&quot;; &#125;&#125;Pepsi.javapublic class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return &quot;Pepsi&quot;; &#125;&#125;步骤 5创建一个 Meal 类，带有上面定义的 Item 对象。Meal.javaimport java.util.ArrayList;import java.util.List;public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print(&quot;Item : &quot;+item.name()); System.out.print(&quot;, Packing : &quot;+item.packing().pack()); System.out.println(&quot;, Price : &quot;+item.price()); &#125; &#125; &#125;步骤 6创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。MealBuilder.javapublic class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125;步骤 7BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。BuilderPatternDemo.javapublic class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(&quot;Veg Meal&quot;); vegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(&quot;\n\nNon-Veg Meal&quot;); nonVegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost()); &#125;&#125;步骤 8验证输出。Veg MealItem : Veg Burger, Packing : Wrapper, Price : 25.0Item : Coke, Packing : Bottle, Price : 30.0Total Cost: 55.0Non-Veg MealItem : Chicken Burger, Packing : Wrapper, Price : 50.5Item : Pepsi, Packing : Bottle, Price : 35.0Total Cost: 85.5]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 抽象工厂模式包含如下角色：AbstractFactory：抽象工厂ConcreteFactory：具体工厂AbstractProduct：抽象产品Product：具体产品 实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189步骤 1为形状创建一个接口。Shape.javapublic interface Shape &#123; void draw();&#125;步骤 2创建实现接口的实体类。Rectangle.javapublic class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;Square.javapublic class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;Circle.javapublic class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125;步骤 3为颜色创建一个接口。Color.javapublic interface Color &#123; void fill();&#125;步骤4创建实现接口的实体类。Red.javapublic class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125;Green.javapublic class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125;Blue.javapublic class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125;步骤 5为 Color 和 Shape 对象创建抽象类来获取工厂。AbstractFactory.javapublic abstract class AbstractFactory &#123; abstract Color getColor(String color); abstract Shape getShape(String shape) ;&#125;步骤 6创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。ShapeFactory.javapublic class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override Color getColor(String color) &#123; return null; &#125;&#125;ColorFactory.javapublic class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125;步骤 7创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。FactoryProducer.javapublic class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125;步骤 8使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。AbstractFactoryPatternDemo.javapublic class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;Green&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125;步骤 9验证输出。Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 实现我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970步骤 1创建桥接实现接口。DrawAPI.javapublic interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;步骤 2创建实现了 DrawAPI 接口的实体桥接实现类。RedCircle.javapublic class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: red, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;GreenCircle.javapublic class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println(&quot;Drawing Circle[ color: green, radius: &quot; + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;); &#125;&#125;步骤 3使用 DrawAPI 接口创建抽象类 Shape。Shape.javapublic abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125;步骤 4创建实现了 Shape 接口的实体类。Circle.javapublic class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125;步骤 5使用 Shape 和 DrawAPI 类画出不同颜色的圆。BridgePatternDemo.javapublic class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125;步骤 6验证输出。Drawing Circle[ color: red, radius: 10, x: 100, 100]Drawing Circle[ color: green, radius: 10, x: 100, 100]`]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模板模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182步骤 1创建一个抽象类，它的模板方法被设置为 final。Game.javapublic abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;步骤 2创建扩展了上述类的实体类。Cricket.javapublic class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println(&quot;Cricket Game Finished!&quot;); &#125; @Override void initialize() &#123; System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;); &#125; @Override void startPlay() &#123; System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;); &#125;&#125;Football.javapublic class Football extends Game &#123; @Override void endPlay() &#123; System.out.println(&quot;Football Game Finished!&quot;); &#125; @Override void initialize() &#123; System.out.println(&quot;Football Game Initialized! Start playing.&quot;); &#125; @Override void startPlay() &#123; System.out.println(&quot;Football Game Started. Enjoy the game!&quot;); &#125;&#125;步骤 3使用 Game 的模板方法 play() 来演示游戏的定义方式。TemplatePatternDemo.javapublic class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125;步骤 4验证输出。Cricket Game Initialized! Start playing.Cricket Game Started. Enjoy the game!Cricket Game Finished!Football Game Initialized! Start playing.Football Game Started. Enjoy the game!Football Game Finished!]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 实现我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374步骤 1创建一个接口。State.javapublic interface State &#123; public void doAction(Context context);&#125;步骤 2创建实现接口的实体类。StartState.javapublic class StartState implements State &#123; public void doAction(Context context) &#123; System.out.println(&quot;Player is in start state&quot;); context.setState(this); &#125; public String toString()&#123; return &quot;Start State&quot;; &#125;&#125;StopState.javapublic class StopState implements State &#123; public void doAction(Context context) &#123; System.out.println(&quot;Player is in stop state&quot;); context.setState(this); &#125; public String toString()&#123; return &quot;Stop State&quot;; &#125;&#125;步骤 3创建 Context 类。Context.javapublic class Context &#123; private State state; public Context()&#123; state = null; &#125; public void setState(State state)&#123; this.state = state; &#125; public State getState()&#123; return state; &#125;&#125;步骤 4使用 Context 来查看当状态 State 改变时的行为变化。StatePatternDemo.javapublic class StatePatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); &#125;&#125;步骤 5验证输出。Player is in start stateStart StatePlayer is in stop stateStop State]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[空对象模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 #实现我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081步骤 1创建一个抽象类。AbstractCustomer.javapublic abstract class AbstractCustomer &#123; protected String name; public abstract boolean isNil(); public abstract String getName();&#125;步骤 2创建扩展了上述类的实体类。RealCustomer.javapublic class RealCustomer extends AbstractCustomer &#123; public RealCustomer(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public boolean isNil() &#123; return false; &#125;&#125;NullCustomer.javapublic class NullCustomer extends AbstractCustomer &#123; @Override public String getName() &#123; return &quot;Not Available in Customer Database&quot;; &#125; @Override public boolean isNil() &#123; return true; &#125;&#125;步骤 3创建 CustomerFactory 类。CustomerFactory.javapublic class CustomerFactory &#123; public static final String[] names = &#123;&quot;Rob&quot;, &quot;Joe&quot;, &quot;Julie&quot;&#125;; public static AbstractCustomer getCustomer(String name)&#123; for (int i = 0; i &lt; names.length; i++) &#123; if (names[i].equalsIgnoreCase(name))&#123; return new RealCustomer(name); &#125; &#125; return new NullCustomer(); &#125;&#125;步骤 4使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。NullPatternDemo.javapublic class NullPatternDemo &#123; public static void main(String[] args) &#123; AbstractCustomer customer1 = CustomerFactory.getCustomer(&quot;Rob&quot;); AbstractCustomer customer2 = CustomerFactory.getCustomer(&quot;Bob&quot;); AbstractCustomer customer3 = CustomerFactory.getCustomer(&quot;Julie&quot;); AbstractCustomer customer4 = CustomerFactory.getCustomer(&quot;Laura&quot;); System.out.println(&quot;Customers&quot;); System.out.println(customer1.getName()); System.out.println(customer2.getName()); System.out.println(customer3.getName()); System.out.println(customer4.getName()); &#125;&#125;步骤 5验证输出。CustomersRobNot Available in Customer DatabaseJulieNot Available in Customer Database]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 实现我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263步骤 1创建一个接口。Strategy.javapublic interface Strategy &#123; public int doOperation(int num1, int num2);&#125;步骤 2创建实现接口的实体类。OperationAdd.javapublic class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125;OperationSubstract.javapublic class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125;OperationMultiply.javapublic class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125;步骤 3创建 Context 类。Context.javapublic class Context &#123; private Strategy strategy; public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); &#125;&#125;步骤 4使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo.javapublic class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5)); &#125;&#125;步骤 5验证输出。10 + 5 = 1510 - 5 = 510 * 5 = 50]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 实现我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283步骤 1创建 Employee 类，该类带有 Employee 对象的列表。Employee.javaimport java.util.ArrayList;import java.util.List;public class Employee &#123; private String name; private String dept; private int salary; private List&lt;Employee&gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) &#123; this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&lt;Employee&gt;(); &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; public List&lt;Employee&gt; getSubordinates()&#123; return subordinates; &#125; public String toString()&#123; return (&quot;Employee :[ Name : &quot;+ name +&quot;, dept : &quot;+ dept + &quot;, salary :&quot; + salary+&quot; ]&quot;); &#125; &#125;步骤 2使用 Employee 类来创建和打印员工的层次结构。CompositePatternDemo.javapublic class CompositePatternDemo &#123; public static void main(String[] args) &#123; Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000); Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000); Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000); Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000); Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000); Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000); Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) &#123; System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) &#123; System.out.println(employee); &#125; &#125; &#125;&#125;步骤 3验证输出。Employee :[ Name : John, dept : CEO, salary :30000 ]Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]Employee :[ Name : Richard, dept : Sales, salary :10000 ]Employee :[ Name : Rob, dept : Sales, salary :10000 ]Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]Employee :[ Name : Laura, dept : Marketing, salary :10000 ]Employee :[ Name : Bob, dept : Marketing, salary :10000 ]]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990步骤 1创建一个接口。Shape.javapublic interface Shape &#123; void draw();&#125;步骤 2创建实现接口的实体类。Rectangle.javapublic class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Rectangle&quot;); &#125;&#125;Circle.javapublic class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape: Circle&quot;); &#125;&#125;步骤 3创建实现了 Shape 接口的抽象装饰类。ShapeDecorator.javapublic abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape)&#123; this.decoratedShape = decoratedShape; &#125; public void draw()&#123; decoratedShape.draw(); &#125; &#125;步骤 4创建扩展了 ShapeDecorator 类的实体装饰类。RedShapeDecorator.javapublic class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape)&#123; System.out.println(&quot;Border Color: Red&quot;); &#125;&#125;步骤 5使用 RedShapeDecorator 来装饰 Shape 对象。DecoratorPatternDemo.javapublic class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(&quot;Circle with normal border&quot;); circle.draw(); System.out.println(&quot;\nCircle of red border&quot;); redCircle.draw(); System.out.println(&quot;\nRectangle of red border&quot;); redRectangle.draw(); &#125;&#125;步骤 6验证输出。Circle with normal borderShape: CircleCircle of red borderShape: CircleBorder Color: RedRectangle of red borderShape: RectangleBorder Color: Red]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 实现观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 ````步骤 1创建 Subject 类。Subject.javaimport java.util.ArrayList;import java.util.List; public class Subject { private List observers = new ArrayList(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } }}步骤 2创建 Observer 类。Observer.javapublic abstract class Observer { protected Subject subject; public abstract void update();}步骤 3创建实体观察者类。BinaryObserver.javapublic class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( “Binary String: “ + Integer.toBinaryString( subject.getState() ) ); }}OctalObserver.javapublic class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( “Octal String: “ + Integer.toOctalString( subject.getState() ) ); }}HexaObserver.javapublic class HexaObserver extends Observer{ public HexaObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( “Hex String: “ + Integer.toHexString( subject.getState() ).toUpperCase() ); }}步骤 4使用 Subject 和实体观察者对象。ObserverPatternDemo.javapublic class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(&quot;First state change: 15&quot;); subject.setState(15); System.out.println(&quot;Second state change: 10&quot;); subject.setState(10); }}步骤 5验证输出。First state change: 15Hex String: FOctal String: 17Binary String: 1111Second state change: 10Hex String: AOctal String: 12Binary String: 1010``]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 实现我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990步骤 1创建一个表达式接口。Expression.javapublic interface Expression &#123; public boolean interpret(String context);&#125;步骤 2创建实现了上述接口的实体类。TerminalExpression.javapublic class TerminalExpression implements Expression &#123; private String data; public TerminalExpression(String data)&#123; this.data = data; &#125; @Override public boolean interpret(String context) &#123; if(context.contains(data))&#123; return true; &#125; return false; &#125;&#125;OrExpression.javapublic class OrExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) || expr2.interpret(context); &#125;&#125;AndExpression.javapublic class AndExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) &amp;&amp; expr2.interpret(context); &#125;&#125;步骤 3InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。InterpreterPatternDemo.javapublic class InterpreterPatternDemo &#123; //规则：Robert 和 John 是男性 public static Expression getMaleExpression()&#123; Expression robert = new TerminalExpression(&quot;Robert&quot;); Expression john = new TerminalExpression(&quot;John&quot;); return new OrExpression(robert, john); &#125; //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression()&#123; Expression julie = new TerminalExpression(&quot;Julie&quot;); Expression married = new TerminalExpression(&quot;Married&quot;); return new AndExpression(julie, married); &#125; public static void main(String[] args) &#123; Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;)); System.out.println(&quot;Julie is a married women? &quot; + isMarriedWoman.interpret(&quot;Married Julie&quot;)); &#125;&#125;步骤 4验证输出。John is male? trueJulie is a married women? true]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 实现我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105步骤 1创建抽象的记录器类。AbstractLogger.javapublic abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger)&#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message)&#123; if(this.level &lt;= level)&#123; write(message); &#125; if(nextLogger !=null)&#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message); &#125;步骤 2创建扩展了该记录器类的实体类。ConsoleLogger.javapublic class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;Standard Console::Logger: &quot; + message); &#125;&#125;ErrorLogger.javapublic class ErrorLogger extends AbstractLogger &#123; public ErrorLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;Error Console::Logger: &quot; + message); &#125;&#125;FileLogger.javapublic class FileLogger extends AbstractLogger &#123; public FileLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;File::Logger: &quot; + message); &#125;&#125;步骤 3创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。ChainPatternDemo.javapublic class ChainPatternDemo &#123; private static AbstractLogger getChainOfLoggers()&#123; AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; &#125; public static void main(String[] args) &#123; AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, &quot;This is an information.&quot;); loggerChain.logMessage(AbstractLogger.DEBUG, &quot;This is an debug level information.&quot;); loggerChain.logMessage(AbstractLogger.ERROR, &quot;This is an error information.&quot;); &#125;&#125;步骤 4验证输出。Standard Console::Logger: This is an information.File::Logger: This is an debug level information.Standard Console::Logger: This is an debug level information.Error Console::Logger: This is an error information.File::Logger: This is an error information.Standard Console::Logger: This is an error information.]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 实现我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。```步骤 1定义一个表示元素的接口。ComputerPart.javapublic interface ComputerPart { public void accept(ComputerPartVisitor computerPartVisitor);}步骤 2创建扩展了上述类的实体类。Keyboard.javapublic class Keyboard implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); }}Monitor.javapublic class Monitor implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); }}Mouse.javapublic class Mouse implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); }}Computer.javapublic class Computer implements ComputerPart { ComputerPart[] parts; public Computer(){ parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()}; } @Override public void accept(ComputerPartVisitor computerPartVisitor) { for (int i = 0; i &lt; parts.length; i++) { parts[i].accept(computerPartVisitor); } computerPartVisitor.visit(this); }}步骤 3定义一个表示访问者的接口。ComputerPartVisitor.javapublic interface ComputerPartVisitor { public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor);}步骤 4创建实现了上述类的实体访问者。ComputerPartDisplayVisitor.javapublic class ComputerPartDisplayVisitor implements ComputerPartVisitor { @Override public void visit(Computer computer) { System.out.println(“Displaying Computer.”); } @Override public void visit(Mouse mouse) { System.out.println(“Displaying Mouse.”); } @Override public void visit(Keyboard keyboard) { System.out.println(“Displaying Keyboard.”); } @Override public void visit(Monitor monitor) { System.out.println(“Displaying Monitor.”); }}步骤 5使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。VisitorPatternDemo.javapublic class VisitorPatternDemo { public static void main(String[] args) { ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); }}步骤 6验证输出。Displaying Mouse.Displaying Keyboard.Displaying Monitor.Displaying Computer.``]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[过滤器模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 实现我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199步骤 1创建一个类，在该类上应用标准。Person.javapublic class Person &#123; private String name; private String gender; private String maritalStatus; public Person(String name,String gender,String maritalStatus)&#123; this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125; public String getMaritalStatus() &#123; return maritalStatus; &#125; &#125;步骤 2为标准（Criteria）创建一个接口。Criteria.javaimport java.util.List;public interface Criteria &#123; public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);&#125;步骤 3创建实现了 Criteria 接口的实体类。CriteriaMale.javaimport java.util.ArrayList;import java.util.List;public class CriteriaMale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;))&#123; malePersons.add(person); &#125; &#125; return malePersons; &#125;&#125;CriteriaFemale.javaimport java.util.ArrayList;import java.util.List;public class CriteriaFemale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;))&#123; femalePersons.add(person); &#125; &#125; return femalePersons; &#125;&#125;CriteriaSingle.javaimport java.util.ArrayList;import java.util.List;public class CriteriaSingle implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;))&#123; singlePersons.add(person); &#125; &#125; return singlePersons; &#125;&#125;AndCriteria.javaimport java.util.List;public class AndCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons); return otherCriteria.meetCriteria(firstCriteriaPersons); &#125;&#125;OrCriteria.javaimport java.util.List;public class OrCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons); List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons); for (Person person : otherCriteriaItems) &#123; if(!firstCriteriaItems.contains(person))&#123; firstCriteriaItems.add(person); &#125; &#125; return firstCriteriaItems; &#125;&#125;步骤4使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表。CriteriaPatternDemo.javaimport java.util.ArrayList; import java.util.List;public class CriteriaPatternDemo &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;)); persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;)); persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;)); persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;)); persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;)); persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;)); Criteria male = new CriteriaMale(); Criteria female = new CriteriaFemale(); Criteria single = new CriteriaSingle(); Criteria singleMale = new AndCriteria(single, male); Criteria singleOrFemale = new OrCriteria(single, female); System.out.println(&quot;Males: &quot;); printPersons(male.meetCriteria(persons)); System.out.println(&quot;\nFemales: &quot;); printPersons(female.meetCriteria(persons)); System.out.println(&quot;\nSingle Males: &quot;); printPersons(singleMale.meetCriteria(persons)); System.out.println(&quot;\nSingle Or Females: &quot;); printPersons(singleOrFemale.meetCriteria(persons)); &#125; public static void printPersons(List&lt;Person&gt; persons)&#123; for (Person person : persons) &#123; System.out.println(&quot;Person : [ Name : &quot; + person.getName() +&quot;, Gender : &quot; + person.getGender() +&quot;, Marital Status : &quot; + person.getMaritalStatus() +&quot; ]&quot;); &#125; &#125; &#125;步骤 5验证输出。Males: Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : John, Gender : Male, Marital Status : Married ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Females: Person : [ Name : Laura, Gender : Female, Marital Status : Married ]Person : [ Name : Diana, Gender : Female, Marital Status : Single ]Single Males: Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Single Or Females: Person : [ Name : Robert, Gender : Male, Marital Status : Single ]Person : [ Name : Diana, Gender : Female, Marital Status : Single ]Person : [ Name : Mike, Gender : Male, Marital Status : Single ]Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]Person : [ Name : Laura, Gender : Female, Marital Status : Married ]]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。 实现我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263步骤 1创建接口。Iterator.javapublic interface Iterator &#123; public boolean hasNext(); public Object next();&#125;Container.javapublic interface Container &#123; public Iterator getIterator();&#125;步骤 2创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。NameRepository.javapublic class NameRepository implements Container &#123; public String names[] = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;; @Override public Iterator getIterator() &#123; return new NameIterator(); &#125; private class NameIterator implements Iterator &#123; int index; @Override public boolean hasNext() &#123; if(index &lt; names.length)&#123; return true; &#125; return false; &#125; @Override public Object next() &#123; if(this.hasNext())&#123; return names[index++]; &#125; return null; &#125; &#125;&#125;步骤 3使用 NameRepository 来获取迭代器，并打印名字。IteratorPatternDemo.javapublic class IteratorPatternDemo &#123; public static void main(String[] args) &#123; NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123; String name = (String)iter.next(); System.out.println(&quot;Name : &quot; + name); &#125; &#125;&#125;步骤 4验证输出。Name : RobertName : JohnName : JulieName : Lora]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 实现我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106步骤 1为媒体播放器和更高级的媒体播放器创建接口。MediaPlayer.javapublic interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125;AdvancedMediaPlayer.javapublic interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125;步骤 2创建实现了 AdvancedMediaPlayer 接口的实体类。VlcPlayer.javapublic class VlcPlayer implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName); &#125; @Override public void playMp4(String fileName) &#123; //什么也不做 &#125;&#125;Mp4Player.javapublic class Mp4Player implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; //什么也不做 &#125; @Override public void playMp4(String fileName) &#123; System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName); &#125;&#125;步骤 3创建实现了 MediaPlayer 接口的适配器类。MediaAdapter.javapublic class MediaAdapter implements MediaPlayer &#123; AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType)&#123; if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123; advancedMusicPlayer.playVlc(fileName); &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125;步骤 4创建实现了 MediaPlayer 接口的实体类。AudioPlayer.javapublic class AudioPlayer implements MediaPlayer &#123; MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) &#123; //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123; System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName); &#125; //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); &#125; else&#123; System.out.println(&quot;Invalid media. &quot;+ audioType + &quot; format not supported&quot;); &#125; &#125; &#125;步骤 5使用 AudioPlayer 来播放不同类型的音频格式。AdapterPatternDemo.javapublic class AdapterPatternDemo &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;); audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;); audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;); audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;); &#125;&#125;步骤 6验证输出。Playing mp3 file. Name: beyond the horizon.mp3Playing mp4 file. Name: alone.mp4Playing vlc file. Name: far far away.vlcInvalid media. avi format not supported]]></content>
      <categories>
        <category>设计模式解读</category>
      </categories>
  </entry>
</search>
